{"version":3,"file":"index.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;ACVa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,yBAAyB,mBAAO,CAAC,iDAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO,MAAM,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sCAAsC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wBAAwB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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PAAmP,GAAG,IAAI,oKAAoK,sHAAsH,IAAI,8PAA8P,GAAG,IAAI,gKAAgK,oGAAoG,kBAAkB,0CAA0C,IAAI,iDAAiD,GAAG,IAAI,sKAAsK,2GAA2G,iBAAiB,4CAA4C,IAAI,kMAAkM,+HAA+H,4JAA4J,kBAAkB,0CAA0C,IAAI,iDAAiD,GAAG,IAAI,sLAAsL,8HAA8H,uJAAuJ,iBAAiB,yDAAyD,IAAI,iNAAiN,oJAAoJ,iBAAiB,4CAA4C,IAAI,2PAA2P,kHAAkH,+BAA+B,IAAI,uJAAuJ,oEAAoE,iBAAiB,4CAA4C,IAAI,wJAAwJ,0JAA0J,iBAAiB,4CAA4C;;;;;;;;;;;ACHlsqJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,eAAe;;;;;;;UC9Kf;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,cAAc;AACnC,kBAAkB,mBAAO,CAAC,mCAAW;AACrC,kBAAkB,mBAAO,CAAC,mCAAW;AACrC,yBAAyB,mBAAO,CAAC,iDAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,aAAa,cAAc,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iCAAiC;AACjC;AACA;AACA,4CAA4C;AAC5C;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB,UAAU,OAAO,IAAI;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA,kBAAkB","sources":["webpack://ebml-to-json/webpack/universalModuleDefinition","webpack://ebml-to-json/./src/Decoder.ts","webpack://ebml-to-json/./src/EbmlSchemaJson.ts","webpack://ebml-to-json/./src/Encoder.ts","webpack://ebml-to-json/webpack/bootstrap","webpack://ebml-to-json/./src/EbmlToJson.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Decoder = void 0;\nconst EbmlSchemaJson_1 = require(\"./EbmlSchemaJson\");\nclass Decoder {\n    buffer;\n    dataView;\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.dataView = new DataView(buffer);\n    }\n    /**\n     * 可変長整数をデコードする\n     * @param start\n     * @returns\n     */\n    readVint(start, withLength = false) {\n        let octetLength = 1;\n        // 左から見て最初に1が登場するbit数 = vintのオクテット長\n        let i = 0;\n        let lengthByte;\n        while ((lengthByte = this.dataView.getUint8(start + i)) === 0) {\n            octetLength += 8;\n            i++;\n        }\n        while ((lengthByte & (0x80 >>> ((octetLength - 1) % 8))) === 0)\n            octetLength++;\n        let value = BigInt(lengthByte);\n        i++;\n        for (; i < octetLength; i++) {\n            value = (value << 8n) | BigInt(this.dataView.getUint8(start + i));\n        }\n        const dataMask = (1n << BigInt(octetLength * 8 - octetLength)) - 1n;\n        if (!withLength)\n            value &= dataMask;\n        return {\n            value,\n            size: octetLength,\n            unknownsize: (value & dataMask) == dataMask\n        };\n    }\n    /**\n     * jsonにデコードする\n     * @returns\n     */\n    decode() {\n        const self = this;\n        let pos = 0;\n        let lastLoaded = null;\n        return (function decode(path = \"\", parentEnd = self.dataView.byteLength) {\n            let elements = [];\n            while (pos < parentEnd) {\n                const element = { pos: { id: {}, size: {}, data: {} } };\n                try {\n                    // Element ID を取得\n                    if (lastLoaded == null) {\n                        const idInfo = self.readVint(pos, true);\n                        element.pos.id.start = pos;\n                        element.id = idInfo.value;\n                        pos += idInfo.size;\n                    }\n                    else {\n                        element.pos.id.start = lastLoaded.start;\n                        element.id = lastLoaded.id;\n                    }\n                    element.pos.id.end = pos;\n                    const id = `0x${element.id.toString(16).toUpperCase()}`;\n                    element.schema = EbmlSchemaJson_1.EbmlSchemaJson.EBMLSchema.element.filter(e => e[\"@id\"] == id)[0];\n                    // データサイズが不明な要素を読み込み中、スキーマと親要素が一致しない要素が出てきたらデータ終わりと判定\n                    const paths = path.split(\"\\\\\").slice(1);\n                    const schemaPaths = element.schema?.[\"@path\"].split(\"\\\\\").slice(1);\n                    if (paths.length > 0) {\n                        if (paths[paths.length - 1] != schemaPaths[schemaPaths.length - 2]) {\n                            return { elements, lastLoaded: { id: element.id, start: element.pos.id.start } };\n                        }\n                    }\n                    lastLoaded = null;\n                    // Size（データ長）を取得\n                    element.pos.size.start = pos;\n                    const sizeInfo = self.readVint(pos);\n                    pos += sizeInfo.size;\n                    element.pos.size.end = pos;\n                    // データ部分の抽出\n                    element.pos.data.start = pos;\n                    if (!sizeInfo.unknownsize) {\n                        element.size = sizeInfo.value;\n                        element.pos.data.end = pos + Number(element.size);\n                    }\n                    if (element.schema[\"@name\"] == \"SimpleBlock\") {\n                        // SimpleBlockの内部構造をデコード\n                        const simpleBlock = {};\n                        // TrackNumber\n                        const trackNumber = self.readVint(pos);\n                        pos += trackNumber.size;\n                        simpleBlock.TrackNumber = trackNumber.value;\n                        // Timestamp\n                        simpleBlock.Timestamp = self.dataView.getInt8(pos++);\n                        simpleBlock.Timestamp <<= 8;\n                        simpleBlock.Timestamp |= self.dataView.getUint8(pos++);\n                        const octet = self.dataView.getUint8(pos);\n                        pos++;\n                        // KEY\n                        simpleBlock.KEY = (octet & 0b10000000) != 0;\n                        // Rsvrd\n                        simpleBlock.Rsvrd = (octet & 0b01110000) >>> 4;\n                        // INV\n                        simpleBlock.INV = (octet & 0b00001000) != 0;\n                        // LACING\n                        simpleBlock.LACING = (octet & 0b00000110) >>> 1;\n                        // DIS\n                        simpleBlock.DIS = (octet & 0b00000001) != 0;\n                        simpleBlock.frameData = self.dataView.buffer.slice(pos, element.pos.data.end);\n                        pos += simpleBlock.frameData.byteLength;\n                        element.data = simpleBlock;\n                    }\n                    else {\n                        if (element.schema?.[\"@type\"] == \"master\") {\n                            element.data;\n                        }\n                        const typ = element.schema?.[\"@type\"];\n                        switch (typ) {\n                            case \"master\":\n                                if (element.size == 0n)\n                                    element.data = [];\n                                else {\n                                    const currentPath = path + \"\\\\\" + element.schema?.[\"@name\"];\n                                    const ret = decode(currentPath, element.pos.data.end ?? parentEnd);\n                                    if (\"lastLoaded\" in ret) {\n                                        lastLoaded = ret.lastLoaded;\n                                    }\n                                    element.data = ret.elements;\n                                }\n                                break;\n                            case \"integer\":\n                                if (element.size > 0) {\n                                    let val = BigInt(self.dataView.getInt8(pos++));\n                                    for (let i = 1; i < element.size; i++) {\n                                        val <<= 8n;\n                                        val |= BigInt(self.dataView.getUint8(pos++));\n                                    }\n                                    element.data = val;\n                                }\n                                else {\n                                    element.data = 0n;\n                                }\n                                break;\n                            case \"uinteger\":\n                                if (element.size > 0) {\n                                    let val = 0n;\n                                    for (let i = 0; i < element.size; i++) {\n                                        val <<= 8n;\n                                        val |= BigInt(self.dataView.getUint8(pos++));\n                                    }\n                                    element.data = val;\n                                }\n                                else {\n                                    element.data = 0n;\n                                }\n                                break;\n                            case \"float\":\n                                if (element.size == 0n)\n                                    element.data = 0;\n                                if (element.size == 4n) {\n                                    element.data = self.dataView.getFloat32(pos, false);\n                                    pos += 4;\n                                }\n                                if (element.size == 8n) {\n                                    element.data = self.dataView.getFloat64(pos, false);\n                                    pos += 8;\n                                }\n                                break;\n                            case \"date\":\n                                let nanos = BigInt(new Date(2001, 0, 1).getTime()) * 1000n * 1000n;\n                                if (element.size > 0) {\n                                    nanos += self.dataView.getBigInt64(pos);\n                                    pos += 8;\n                                }\n                                element.data = { date: new Date(Number(nanos / 1000n / 1000n)), nanos };\n                                break;\n                            default:\n                                const buf = self.dataView.buffer.slice(element.pos.data.start, element.pos.data.end ?? parentEnd);\n                                switch (typ) {\n                                    case \"string\":\n                                        element.data = String.fromCharCode.apply(\"\", new Uint8Array(buf));\n                                        break;\n                                    case \"utf-8\":\n                                        const decoder = new TextDecoder(\"utf-8\");\n                                        element.data = decoder.decode(new Uint8Array(buf));\n                                        break;\n                                    default:\n                                        element.data = buf;\n                                        break;\n                                }\n                                pos += buf.byteLength;\n                                break;\n                        }\n                    }\n                }\n                catch (e) {\n                    if (e.name == \"RangeError\") {\n                        // データが途中で切れている\n                        return { elements, notMachBuffer: self.dataView.buffer.slice(element.pos.id.start) };\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n                if (element.pos.data.end == null)\n                    element.pos.data.end = pos;\n                // else if (element.pos.data.end != pos)\n                //     throw `データの位置がずれている: ${element.pos.data.end} ${pos}`\n                // JSON 構造として保存\n                elements.push(element);\n            }\n            return { elements };\n        })().elements;\n    }\n    /**\n     * SimpleBlockとしてデコードする\n     */\n    decodeSimpleBlock() {\n        const simpleBlock = {};\n        let pos = 0;\n        // TrackNumber\n        const trackNumber = this.readVint(pos);\n        pos += trackNumber.size;\n        simpleBlock.TrackNumber = trackNumber.value;\n        // Timestamp\n        simpleBlock.Timestamp = this.dataView.getUint16(pos);\n        pos += 2;\n        const octet = this.dataView.getUint8(pos);\n        pos++;\n        // KEY\n        simpleBlock.KEY = (octet & 0b10000000) != 0;\n        // Rsvrd\n        simpleBlock.Rsvrd = (octet & 0b01110000) >>> 4;\n        // INV\n        simpleBlock.INV = (octet & 0b00001000) != 0;\n        // LACING\n        simpleBlock.LACING = (octet & 0b00000110) >>> 1;\n        // DIS\n        simpleBlock.DIS = (octet & 0b00000001) != 0;\n        simpleBlock.frameData = this.dataView.buffer.slice(pos);\n        return simpleBlock;\n    }\n}\nexports.Decoder = Decoder;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EbmlSchemaJson = void 0;\nexports.EbmlSchemaJson = { \"EBMLSchema\": { \"@xmlns\": \"urn:ietf:rfc:8794\", \"@docType\": \"ebml\", \"@version\": \"1\", \"element\": [{ \"@name\": \"EBML\", \"@path\": \"\\\\EBML\", \"@id\": \"0x1A45DFA3\", \"@type\": \"master\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Set the EBML characteristics of the data to follow. Each EBML document has to start with this.\" } }, { \"@name\": \"EBMLVersion\", \"@path\": \"\\\\EBML\\\\EBMLVersion\", \"@id\": \"0x4286\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@default\": \"1\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The version of EBML parser used to create the file.\" } }, { \"@name\": \"EBMLReadVersion\", \"@path\": \"\\\\EBML\\\\EBMLReadVersion\", \"@id\": \"0x42F7\", \"@type\": \"uinteger\", \"@range\": \"1\", \"@default\": \"1\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The minimum EBML version a parser has to support to read this file.\" } }, { \"@name\": \"EBMLMaxIDLength\", \"@path\": \"\\\\EBML\\\\EBMLMaxIDLength\", \"@id\": \"0x42F2\", \"@type\": \"uinteger\", \"@range\": \">=4\", \"@default\": \"4\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The maximum length of the IDs you'll find in this file (4 or less in Matroska).\" } }, { \"@name\": \"EBMLMaxSizeLength\", \"@path\": \"\\\\EBML\\\\EBMLMaxSizeLength\", \"@id\": \"0x42F3\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@default\": \"8\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The maximum length of the sizes you'll find in this file (8 or less in Matroska). This does not override the element size indicated at the beginning of an element. Elements that have an indicated size which is larger than what is allowed by EBMLMaxSizeLength shall be considered invalid.\" } }, { \"@name\": \"DocType\", \"@path\": \"\\\\EBML\\\\DocType\", \"@id\": \"0x4282\", \"@type\": \"string\", \"@length\": \">0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A string that describes the type of document that follows this EBML header, for example 'matroska' or 'webm'.\" } }, { \"@name\": \"DocTypeVersion\", \"@path\": \"\\\\EBML\\\\DocTypeVersion\", \"@id\": \"0x4287\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@default\": \"1\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The version of DocType interpreter used to create the file.\" } }, { \"@name\": \"DocTypeReadVersion\", \"@path\": \"\\\\EBML\\\\DocTypeReadVersion\", \"@id\": \"0x4285\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@default\": \"1\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The minimum DocType version an interpreter has to support to read this file.\" } }, { \"@name\": \"DocTypeExtension\", \"@path\": \"\\\\EBML\\\\DocTypeExtension\", \"@id\": \"0x4281\", \"@type\": \"master\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A DocTypeExtension adds extra Elements to the main DocType+DocTypeVersion\\ttuple it's attached to. An EBML Reader **MAY** know these extra Elements and how to use them. A DocTypeExtension **MAY** be used to iterate between\\texperimental Elements before they are integrated into a regular\\tDocTypeVersion. Reading one DocTypeExtension version of a DocType+DocTypeVersion tuple doesn't imply one should be able to read upper versions of this DocTypeExtension.\" } }, { \"@name\": \"DocTypeExtensionName\", \"@path\": \"\\\\EBML\\\\DocTypeExtension\\\\DocTypeExtensionName\", \"@id\": \"0x4283\", \"@type\": \"string\", \"@length\": \">0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The name of the DocTypeExtension to differentiate it from other DocTypeExtensions of the same DocType+DocTypeVersion tuple. A DocTypeExtensionName value **MUST** be unique within the EBML Header.\" } }, { \"@name\": \"DocTypeExtensionVersion\", \"@path\": \"\\\\EBML\\\\DocTypeExtension\\\\DocTypeExtensionVersion\", \"@id\": \"0x4284\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The version of the DocTypeExtension. Different DocTypeExtensionVersion values of the same DocType + DocTypeVersion + DocTypeExtensionName tuple **MAY** contain completely different sets of extra Elements. An EBML Reader **MAY** support multiple versions\\tof the same tuple, only one version of the tuple, or not support the tuple at all.\" } }, { \"@name\": \"Void\", \"@path\": \"\\\\(-\\\\)Void\", \"@id\": \"0xEC\", \"@type\": \"binary\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Used to void damaged data, to avoid unexpected behaviors when using damaged data. The content is discarded. Also used to reserve space in a sub-element for later use.\" } }, { \"@name\": \"CRC-32\", \"@path\": \"\\\\(1-\\\\)CRC-32\", \"@id\": \"0xBF\", \"@type\": \"binary\", \"@length\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The CRC is computed on all the data of the Master element it's in. The CRC element should be the first in it's parent master for easier reading. All level 1 elements should include a CRC-32. The CRC in use is the IEEE CRC32 Little Endian.\" } }, { \"@name\": \"EBMLMaxIDLength\", \"@path\": \"\\\\EBML\\\\EBMLMaxIDLength\", \"@id\": \"0x42F2\", \"@type\": \"uinteger\", \"@range\": \"4\", \"@default\": \"4\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\" }, { \"@name\": \"EBMLMaxSizeLength\", \"@path\": \"\\\\EBML\\\\EBMLMaxSizeLength\", \"@id\": \"0x42F3\", \"@type\": \"uinteger\", \"@range\": \"1-8\", \"@default\": \"8\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\" }, { \"@name\": \"Segment\", \"@path\": \"\\\\Segment\", \"@id\": \"0x18538067\", \"@type\": \"master\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"@unknownsizeallowed\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `Root Element` that contains all other `Top-Level Elements`; see (#data-layout).\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"SeekHead\", \"@path\": \"\\\\Segment\\\\SeekHead\", \"@id\": \"0x114D9B74\", \"@type\": \"master\", \"@maxOccurs\": \"2\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains seeking information of `Top-Level Elements`; see (#data-layout).\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"Seek\", \"@path\": \"\\\\Segment\\\\SeekHead\\\\Seek\", \"@id\": \"0x4DBB\", \"@type\": \"master\", \"@minOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains a single seek entry to an EBML Element.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"SeekID\", \"@path\": \"\\\\Segment\\\\SeekHead\\\\Seek\\\\SeekID\", \"@id\": \"0x53AB\", \"@type\": \"binary\", \"@length\": \"4\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The binary EBML ID of a `Top-Level Element`.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"SeekPosition\", \"@path\": \"\\\\Segment\\\\SeekHead\\\\Seek\\\\SeekPosition\", \"@id\": \"0x53AC\", \"@type\": \"uinteger\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `Segment Position` ((#segment-position)) of a `Top-Level Element`.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"Info\", \"@path\": \"\\\\Segment\\\\Info\", \"@id\": \"0x1549A966\", \"@type\": \"master\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"@recurring\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains general information about the `Segment`.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"SegmentUUID\", \"@path\": \"\\\\Segment\\\\Info\\\\SegmentUUID\", \"@id\": \"0x73A4\", \"@type\": \"binary\", \"@length\": \"16\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A randomly generated UID that identifies the `Segment` amongst many others (128 bits). It is equivalent to a Universally Unique Identifier (UUID) v4 [@!RFC9562] with all bits randomly (or pseudorandomly) chosen. An actual UUID v4 value, where some bits are not random, **MAY** also be used.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"If the `Segment` is a part of a `Linked Segment`, then this element is **REQUIRED**.\\nThe value of the UID **MUST** contain at least one bit set to 1.\" }], \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"SegmentUID\" } }, { \"@name\": \"SegmentFilename\", \"@path\": \"\\\\Segment\\\\Info\\\\SegmentFilename\", \"@id\": \"0x7384\", \"@type\": \"utf-8\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A filename corresponding to this `Segment`.\" } }, { \"@name\": \"PrevUUID\", \"@path\": \"\\\\Segment\\\\Info\\\\PrevUUID\", \"@id\": \"0x3CB923\", \"@type\": \"binary\", \"@length\": \"16\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"An ID that identifies the previous `Segment` of a `Linked Segment`.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"If the `Segment` is a part of a `Linked Segment` that uses\\nHard Linking ((#hard-linking)), then either the\\n`PrevUUID` or the `NextUUID` element is\\n**REQUIRED**. If a `Segment` contains a `PrevUUID`\\nbut not a `NextUUID`, then it **MAY** be considered as the\\nlast `Segment` of the `Linked Segment`. The `PrevUUID`\\n**MUST NOT** be equal to the `SegmentUUID`.\" }], \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"PrevUID\" } }, { \"@name\": \"PrevFilename\", \"@path\": \"\\\\Segment\\\\Info\\\\PrevFilename\", \"@id\": \"0x3C83AB\", \"@type\": \"utf-8\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A filename corresponding to the file of the previous `Linked Segment`.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"Provision of the previous filename is for display convenience,\\nbut `PrevUUID` **SHOULD** be considered authoritative for identifying the previous `Segment` in a `Linked Segment`.\" }] }, { \"@name\": \"NextUUID\", \"@path\": \"\\\\Segment\\\\Info\\\\NextUUID\", \"@id\": \"0x3EB923\", \"@type\": \"binary\", \"@length\": \"16\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"An ID that identifies the next `Segment` of a `Linked Segment`.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"If the `Segment` is a part of a `Linked Segment` that uses Hard Linking ((#hard-linking)),\\nthen either the `PrevUUID` or the `NextUUID` element is **REQUIRED**. If a `Segment` contains a `NextUUID` but not a `PrevUUID`, then it **MAY** be considered as the first `Segment` of the `Linked Segment`. The `NextUUID` **MUST NOT** be equal to the `SegmentUUID`.\" }], \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"NextUID\" } }, { \"@name\": \"NextFilename\", \"@path\": \"\\\\Segment\\\\Info\\\\NextFilename\", \"@id\": \"0x3E83BB\", \"@type\": \"utf-8\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A filename corresponding to the file of the next `Linked Segment`.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"Provision of the next filename is for display convenience,\\nbut `NextUUID` **SHOULD** be considered authoritative for identifying the Next `Segment`.\" }] }, { \"@name\": \"SegmentFamily\", \"@path\": \"\\\\Segment\\\\Info\\\\SegmentFamily\", \"@id\": \"0x4444\", \"@type\": \"binary\", \"@length\": \"16\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A UID that all `Segments` of a `Linked Segment` **MUST** share (128 bits). It is equivalent to a UUID v4 [@!RFC9562] with all bits randomly (or pseudorandomly) chosen. An actual UUID v4 value, where some bits are not random, **MAY** also be used.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"If the `Segment` `Info` contains a `ChapterTranslate` element, this element is **REQUIRED**.\" }] }, { \"@name\": \"ChapterTranslate\", \"@path\": \"\\\\Segment\\\\Info\\\\ChapterTranslate\", \"@id\": \"0x6924\", \"@type\": \"master\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The mapping between this `Segment` and a\\n segment value in the given Chapter Codec.\" }, { \"@lang\": \"en\", \"@purpose\": \"rationale\", \"#text\": \"Chapter Codecs may need to address different segments, but they may not know of the way to identify such segments when stored in Matroska.\\nThis element and its child elements add a way to map the internal segments known to the Chapter Codec to the `SegmentUUID`s in Matroska.\\nThis allows remuxing a file with Chapter Codec without changing the content of the codec data, just the `Segment` mapping.\" }] }, { \"@name\": \"ChapterTranslateID\", \"@path\": \"\\\\Segment\\\\Info\\\\ChapterTranslate\\\\ChapterTranslateID\", \"@id\": \"0x69A5\", \"@type\": \"binary\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The binary value used to represent this `Segment` in the chapter codec data.\\nThe format depends on the `ChapProcessCodecID` used; see (#chapprocesscodecid-element).\" } }, { \"@name\": \"ChapterTranslateCodec\", \"@path\": \"\\\\Segment\\\\Info\\\\ChapterTranslate\\\\ChapterTranslateCodec\", \"@id\": \"0x69BF\", \"@type\": \"uinteger\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Applies to the chapter codec of the given chapter edition(s); see (#chapprocesscodecid-element).\" }, \"extension\": { \"@type\": \"enum source\", \"@source\": \"Chapter Codec ID\" } }, { \"@name\": \"ChapterTranslateEditionUID\", \"@path\": \"\\\\Segment\\\\Info\\\\ChapterTranslate\\\\ChapterTranslateEditionUID\", \"@id\": \"0x69FC\", \"@type\": \"uinteger\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Specifies a chapter edition UID to which this `ChapterTranslate` applies.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"When no `ChapterTranslateEditionUID` is specified in the `ChapterTranslate`, the `ChapterTranslate` applies to all chapter editions found in the `Segment` using the given `ChapterTranslateCodec`.\" }] }, { \"@name\": \"TimestampScale\", \"@path\": \"\\\\Segment\\\\Info\\\\TimestampScale\", \"@id\": \"0x2AD7B1\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@default\": \"1000000\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Base unit for Segment Ticks and Track Ticks, in nanoseconds. A `TimestampScale` value of 1000000 means scaled timestamps in the `Segment` are expressed in milliseconds; see (#timestamps) on how to interpret timestamps.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"TimecodeScale\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"Duration\", \"@path\": \"\\\\Segment\\\\Info\\\\Duration\", \"@id\": \"0x4489\", \"@type\": \"float\", \"@range\": \"> 0x0p+0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Duration of the `Segment`, expressed in `Segment` Ticks, which are based on `TimestampScale`; see (#timestamp-ticks).\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"DateUTC\", \"@path\": \"\\\\Segment\\\\Info\\\\DateUTC\", \"@id\": \"0x4461\", \"@type\": \"date\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The date and time that the `Segment` was created by the muxing application or library.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"Title\", \"@path\": \"\\\\Segment\\\\Info\\\\Title\", \"@id\": \"0x7BA9\", \"@type\": \"utf-8\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"General name of the `Segment`.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"MuxingApp\", \"@path\": \"\\\\Segment\\\\Info\\\\MuxingApp\", \"@id\": \"0x4D80\", \"@type\": \"utf-8\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Muxing application or library (example: \\\"libmatroska-0.4.3\\\").\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"Include the full name of the application or library followed by the version number.\" }], \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"WritingApp\", \"@path\": \"\\\\Segment\\\\Info\\\\WritingApp\", \"@id\": \"0x5741\", \"@type\": \"utf-8\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Writing application (example: \\\"mkvmerge-0.3.3\\\").\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"Include the full name of the application followed by the version number.\" }], \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"Cluster\", \"@path\": \"\\\\Segment\\\\Cluster\", \"@id\": \"0x1F43B675\", \"@type\": \"master\", \"@unknownsizeallowed\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `Top-Level Element` containing the (monolithic) `Block` structure.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"Timestamp\", \"@path\": \"\\\\Segment\\\\Cluster\\\\Timestamp\", \"@id\": \"0xE7\", \"@type\": \"uinteger\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Absolute timestamp of the cluster, expressed in Segment Ticks, which are based on `TimestampScale`; see (#timestamp-ticks).\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"This element **SHOULD** be the first child element of the `Cluster` it belongs to\\nor the second if that `Cluster` contains a `CRC-32` element ((#crc-32)).\" }], \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"ClusterTimecode\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"SilentTracks\", \"@path\": \"\\\\Segment\\\\Cluster\\\\SilentTracks\", \"@id\": \"0x5854\", \"@type\": \"master\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The list of tracks that are not used in that part of the stream.\\nIt is useful when using overlay tracks for seeking or deciding what track to use.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"ClusterSilentTracks\" } }, { \"@name\": \"SilentTrackNumber\", \"@path\": \"\\\\Segment\\\\Cluster\\\\SilentTracks\\\\SilentTrackNumber\", \"@id\": \"0x58D7\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"One of the track numbers that is not used from now on in the stream.\\nIt could change later if not specified as silent in a further `Cluster`.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"ClusterSilentTrackNumber\" } }, { \"@name\": \"Position\", \"@path\": \"\\\\Segment\\\\Cluster\\\\Position\", \"@id\": \"0xA7\", \"@type\": \"uinteger\", \"@maxver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `Segment Position` of the `Cluster` in the `Segment` (0 in live streams).\\nIt might help to resynchronize the offset on damaged streams.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"ClusterPosition\" } }, { \"@name\": \"PrevSize\", \"@path\": \"\\\\Segment\\\\Cluster\\\\PrevSize\", \"@id\": \"0xAB\", \"@type\": \"uinteger\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Size of the previous `Cluster`, in octets. Can be useful for backward playing.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"ClusterPrevSize\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"SimpleBlock\", \"@path\": \"\\\\Segment\\\\Cluster\\\\SimpleBlock\", \"@id\": \"0xA3\", \"@type\": \"binary\", \"@minver\": \"2\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Similar to `Block` (see (#block-structure)) but without all the extra information.\\nMostly used to reduce overhead when no extra feature is needed; see (#simpleblock-structure) on `SimpleBlock` Structure.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"divx.com\", \"@divx\": \"1\" }] }, { \"@name\": \"BlockGroup\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\", \"@id\": \"0xA0\", \"@type\": \"master\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Basic container of information containing a single `Block` and information specific to that `Block`.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"Block\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\Block\", \"@id\": \"0xA1\", \"@type\": \"binary\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"`Block` containing the actual data to be rendered and a timestamp relative to the `Cluster` Timestamp;\\nsee (#block-structure) on `Block` Structure.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"BlockVirtual\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\BlockVirtual\", \"@id\": \"0xA2\", \"@type\": \"binary\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A `Block` with no data. It must be stored in the stream at the place the real `Block` would be in display order.\" } }, { \"@name\": \"BlockAdditions\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\BlockAdditions\", \"@id\": \"0x75A1\", \"@type\": \"master\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains additional binary data to complete the `Block` element; see [@?I-D.ietf-cellar-codec, section 4.1.5] for more information.\\nAn EBML parser that has no knowledge of the `Block` structure could still see and use/skip these data.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"BlockMore\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\BlockAdditions\\\\BlockMore\", \"@id\": \"0xA6\", \"@type\": \"master\", \"@minOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains the `BlockAdditional` and some parameters.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"BlockAdditional\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\BlockAdditions\\\\BlockMore\\\\BlockAdditional\", \"@id\": \"0xA5\", \"@type\": \"binary\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Interpreted by the codec as it wishes (using the `BlockAddID`).\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"BlockAddID\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\BlockAdditions\\\\BlockMore\\\\BlockAddID\", \"@id\": \"0xEE\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@default\": \"1\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"An ID that identifies how to interpret the `BlockAdditional` data; see [@?I-D.ietf-cellar-codec, section 4.1.5] for\\n more information. A value of 1 indicates that the `BlockAdditional` data is\\n defined by the codec. Any other value indicates that the `BlockAdditional` data\\n should be handled according to the `BlockAddIDType` that is located in the\\n`TrackEntry`.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"Each `BlockAddID` value **MUST** be unique between all `BlockMore` elements found in a `BlockAdditions` element. To keep `MaxBlockAdditionID` as low as possible, small values **SHOULD** be used.\" }], \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"BlockDuration\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\BlockDuration\", \"@id\": \"0x9B\", \"@type\": \"uinteger\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The duration of the `Block`, expressed in Track Ticks; see (#timestamp-ticks).\\nThe `BlockDuration` element can be useful\\nat the end of a `Track` to define the duration of the last frame (as\\nthere is no subsequent `Block` available) or when there is a break in a\\ntrack like for subtitle tracks.\" }, \"implementation_note\": [{ \"@note_attribute\": \"minOccurs\", \"#text\": \"`BlockDuration` **MUST** be set (minOccurs=1) if the associated `TrackEntry` stores a `DefaultDuration` value.\" }, { \"@note_attribute\": \"default\", \"#text\": \"If a value is not present and no `DefaultDuration` is defined, the value is assumed to be the difference between the timestamp of this `Block` and the timestamp of the next `Block` in \\\"display\\\" order (not coding order).\" }], \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"ReferencePriority\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\ReferencePriority\", \"@id\": \"0xFA\", \"@type\": \"uinteger\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"This frame is referenced and has the specified cache priority.\\nIn the cache, only a frame of the same or higher priority can replace this frame. A value of 0 means the frame is not referenced.\" } }, { \"@name\": \"ReferenceBlock\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\ReferenceBlock\", \"@id\": \"0xFB\", \"@type\": \"integer\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A timestamp value, relative to the timestamp of the `Block` in this `BlockGroup`, expressed in Track Ticks; see (#timestamp-ticks).\\nThis is used to reference other frames necessary to decode this frame.\\nThe relative value **SHOULD** correspond to a valid `Block` that this `Block` depends on.\\nHistorically, `Matroska Writers` didn't write the actual `Block(s)` that this `Block` depends on, but they did write *some* `Block(s)` in the past.\\n\\nThe value \\\"0\\\" **MAY** also be used to signify that this `Block` cannot be decoded on its own, but the necessary reference `Block(s)` is unknown. In this case, other `ReferenceBlock` elements **MUST NOT** be found in the same `BlockGroup`. If the `BlockGroup` doesn't have a `ReferenceBlock` element, then the `Block` it contains can be decoded without using any other `Block` data.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"ReferenceVirtual\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\ReferenceVirtual\", \"@id\": \"0xFD\", \"@type\": \"integer\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `Segment Position` of the data that would otherwise be in position of the virtual block.\" } }, { \"@name\": \"CodecState\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\CodecState\", \"@id\": \"0xA4\", \"@type\": \"binary\", \"@minver\": \"2\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The new codec state to use. Data interpretation is private to the codec.\\nThis information **SHOULD** always be referenced by a seek entry.\" } }, { \"@name\": \"DiscardPadding\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\DiscardPadding\", \"@id\": \"0x75A2\", \"@type\": \"integer\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Duration of the silent data added to the `Block`, expressed in\\n Matroska Ticks -- i.e., in nanoseconds; see (#timestamp-ticks)\\n(padding at the end of the `Block` for positive values and at the\\nbeginning of the `Block` for negative values). The duration of\\n`DiscardPadding` is not calculated in the duration of the\\n`TrackEntry` and **SHOULD** be discarded during\\nplayback.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"Slices\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\Slices\", \"@id\": \"0x8E\", \"@type\": \"master\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains slices description.\" } }, { \"@name\": \"TimeSlice\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\Slices\\\\TimeSlice\", \"@id\": \"0xE8\", \"@type\": \"master\", \"@minver\": \"0\", \"@maxver\": \"0\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains extra time information about the data contained in the `Block`.\\nBeing able to interpret this element is not required for playback.\" } }, { \"@name\": \"LaceNumber\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\Slices\\\\TimeSlice\\\\LaceNumber\", \"@id\": \"0xCC\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The reverse number of the frame in the lace (0 is the last frame, 1 is the next to last, etc.).\\nBeing able to interpret this element is not required for playback.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"SliceLaceNumber\" } }, { \"@name\": \"FrameNumber\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\Slices\\\\TimeSlice\\\\FrameNumber\", \"@id\": \"0xCD\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@default\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The number of the frame to generate from this lace with this delay\\n(allows for the generation of many frames from the same Block/Frame).\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"SliceFrameNumber\" } }, { \"@name\": \"BlockAdditionID\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\Slices\\\\TimeSlice\\\\BlockAdditionID\", \"@id\": \"0xCB\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@default\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The ID of the `BlockAdditional` element (0 is the main `Block`).\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"SliceBlockAddID\" } }, { \"@name\": \"Delay\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\Slices\\\\TimeSlice\\\\Delay\", \"@id\": \"0xCE\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@default\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The delay to apply to the element, expressed in Track Ticks; see (#timestamp-ticks).\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"SliceDelay\" } }, { \"@name\": \"SliceDuration\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\Slices\\\\TimeSlice\\\\SliceDuration\", \"@id\": \"0xCF\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@default\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The duration to apply to the element, expressed in Track Ticks; see (#timestamp-ticks).\" } }, { \"@name\": \"ReferenceFrame\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\ReferenceFrame\", \"@id\": \"0xC8\", \"@type\": \"master\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains information about the last reference frame. See [@?DivXTrickTrack].\" }, \"extension\": { \"@type\": \"divx.com\", \"@divx\": \"1\" } }, { \"@name\": \"ReferenceOffset\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\ReferenceFrame\\\\ReferenceOffset\", \"@id\": \"0xC9\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The relative offset, in bytes, from the previous `BlockGroup` element for this Smooth FF/RW video track to the containing `BlockGroup`\\nelement. See [@?DivXTrickTrack].\" }, \"extension\": { \"@type\": \"divx.com\", \"@divx\": \"1\" } }, { \"@name\": \"ReferenceTimestamp\", \"@path\": \"\\\\Segment\\\\Cluster\\\\BlockGroup\\\\ReferenceFrame\\\\ReferenceTimestamp\", \"@id\": \"0xCA\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The timestamp of the `BlockGroup` pointed to by ReferenceOffset, expressed in Track Ticks; see (#timestamp-ticks). See [@?DivXTrickTrack].\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"ReferenceTimeCode\" }, { \"@type\": \"divx.com\", \"@divx\": \"1\" }] }, { \"@name\": \"EncryptedBlock\", \"@path\": \"\\\\Segment\\\\Cluster\\\\EncryptedBlock\", \"@id\": \"0xAF\", \"@type\": \"binary\", \"@minver\": \"0\", \"@maxver\": \"0\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Similar to `SimpleBlock` (see (#simpleblock-structure)),\\nbut the data inside the `Block` are Transformed (encrypted and/or signed).\" } }, { \"@name\": \"Tracks\", \"@path\": \"\\\\Segment\\\\Tracks\", \"@id\": \"0x1654AE6B\", \"@type\": \"master\", \"@maxOccurs\": \"1\", \"@recurring\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A `Top-Level Element` of information with many tracks described.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"TrackEntry\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\", \"@id\": \"0xAE\", \"@type\": \"master\", \"@minOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Describes a track with all elements.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"TrackNumber\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackNumber\", \"@id\": \"0xD7\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The track number as used in the `Block` Header.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"TrackUID\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackUID\", \"@id\": \"0x73C5\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A UID that identifies the `Track`.\" }, \"extension\": [{ \"@type\": \"stream copy\", \"@keep\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"TrackType\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackType\", \"@id\": \"0x83\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `TrackType` defines the type of each frame found in the `Track`.\\nThe value **SHOULD** be stored on 1 octet.\" }, \"extension\": [{ \"@type\": \"enum source\", \"@registry\": \"Track Type\", \"@policy\": \"Specification Required\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }], \"restriction\": { \"enum\": [{ \"@value\": \"1\", \"@label\": \"video\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"An image.\" } }, { \"@value\": \"2\", \"@label\": \"audio\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Audio samples.\" } }, { \"@value\": \"3\", \"@label\": \"complex\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A mix of different other `TrackType`. The codec needs to define how the `Matroska Player` should interpret such data.\" } }, { \"@value\": \"16\", \"@label\": \"logo\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"An image to be rendered over the video track(s).\" } }, { \"@value\": \"17\", \"@label\": \"subtitle\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Subtitle or closed caption data to be rendered over the video track(s).\" } }, { \"@value\": \"18\", \"@label\": \"buttons\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Interactive button(s) to be rendered over the video track(s).\" } }, { \"@value\": \"32\", \"@label\": \"control\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Metadata used to control the player of the `Matroska Player`.\" } }, { \"@value\": \"33\", \"@label\": \"metadata\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Timed metadata that can be passed on to the `Matroska Player`.\" } }] } }, { \"@name\": \"FlagEnabled\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\FlagEnabled\", \"@id\": \"0xB9\", \"@type\": \"uinteger\", \"@minver\": \"2\", \"@range\": \"0-1\", \"@default\": \"1\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Set to 1 if the track is usable. It is possible to turn a track that is not usable into a usable track using chapter codecs or control tracks.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"TrackFlagEnabled\" }] }, { \"@name\": \"FlagDefault\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\FlagDefault\", \"@id\": \"0x88\", \"@type\": \"uinteger\", \"@range\": \"0-1\", \"@default\": \"1\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Set to 1 if the track (audio, video, or subtitles) is eligible for automatic selection by the player; see (#default-track-selection) for more details.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"TrackFlagDefault\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"FlagForced\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\FlagForced\", \"@id\": \"0x55AA\", \"@type\": \"uinteger\", \"@range\": \"0-1\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Applies only to subtitles. Set to 1 if the track is eligible for automatic selection by the player if it matches the user's language preference,\\neven if the user's preferences would not normally enable subtitles with the selected audio track;\\nthis can be used for tracks containing only translations of audio in foreign languages or on-screen text.\\nSee (#default-track-selection) for more details.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"TrackFlagForced\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"FlagHearingImpaired\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\FlagHearingImpaired\", \"@id\": \"0x55AB\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@range\": \"0-1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Set to 1 if and only if the track is suitable for users with hearing impairments.\" } }, { \"@name\": \"FlagVisualImpaired\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\FlagVisualImpaired\", \"@id\": \"0x55AC\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@range\": \"0-1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Set to 1 if and only if the track is suitable for users with visual impairments.\" } }, { \"@name\": \"FlagTextDescriptions\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\FlagTextDescriptions\", \"@id\": \"0x55AD\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@range\": \"0-1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Set to 1 if and only if the track contains textual descriptions of video content.\" } }, { \"@name\": \"FlagOriginal\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\FlagOriginal\", \"@id\": \"0x55AE\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@range\": \"0-1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Set to 1 if and only if the track is in the content's original language.\" } }, { \"@name\": \"FlagCommentary\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\FlagCommentary\", \"@id\": \"0x55AF\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@range\": \"0-1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Set to 1 if and only if the track contains commentary.\" } }, { \"@name\": \"FlagLacing\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\FlagLacing\", \"@id\": \"0x9C\", \"@type\": \"uinteger\", \"@range\": \"0-1\", \"@default\": \"1\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Set to 1 if the track **MAY** contain blocks that use lacing.\\n When set to 0, all blocks **MUST** have their lacing flags set to \\\"no lacing\\\"; see (#block-lacing) on 'Block' Lacing.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"TrackFlagLacing\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"MinCache\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\MinCache\", \"@id\": \"0x6DE7\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The minimum number of frames a player should be able to cache during playback.\\nIf set to 0, the reference pseudo-cache system is not used.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"TrackMinCache\" } }, { \"@name\": \"MaxCache\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\MaxCache\", \"@id\": \"0x6DF8\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The maximum cache size necessary to store referenced frames in and the current frame.\\n0 means no cache is needed.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"TrackMaxCache\" } }, { \"@name\": \"DefaultDuration\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\DefaultDuration\", \"@id\": \"0x23E383\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Number of nanoseconds per frame, expressed in Matroska Ticks -- i.e., in nanoseconds; see (#timestamp-ticks)\\n(\\\"frame\\\" in the Matroska sense -- one element put into a (Simple)Block).\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"TrackDefaultDuration\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"DefaultDecodedFieldDuration\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\DefaultDecodedFieldDuration\", \"@id\": \"0x234E7A\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@range\": \"not 0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The period between two successive fields at the output of the decoding process, expressed in Matroska Ticks -- i.e., in nanoseconds; see (#timestamp-ticks).\\nSee (#defaultdecodedfieldduration) for more information.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"TrackDefaultDecodedFieldDuration\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"TrackTimestampScale\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackTimestampScale\", \"@id\": \"0x23314F\", \"@type\": \"float\", \"@maxver\": \"3\", \"@range\": \"> 0x0p+0\", \"@default\": \"0x1p+0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The scale to apply on this track to work at normal speed in relation with other tracks\\n(mostly used to adjust video speed when the audio length differs).\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"TrackTimecodeScale\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"TrackOffset\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackOffset\", \"@id\": \"0x537F\", \"@type\": \"integer\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@default\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A value to add to the `Block`'s Timestamp, expressed in Matroska Ticks -- i.e., in nanoseconds; see (#timestamp-ticks).\\nThis can be used to adjust the playback offset of a track.\" }, \"extension\": { \"@type\": \"stream copy\", \"@keep\": \"1\" } }, { \"@name\": \"MaxBlockAdditionID\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\MaxBlockAdditionID\", \"@id\": \"0x55EE\", \"@type\": \"uinteger\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The maximum value of `BlockAddID` ((#blockaddid-element)).\\nA value of 0 means there is no `BlockAdditions` ((#blockadditions-element)) for this track.\" } }, { \"@name\": \"BlockAdditionMapping\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\BlockAdditionMapping\", \"@id\": \"0x41E4\", \"@type\": \"master\", \"@minver\": \"4\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains elements that extend the track format by adding content either to each frame,\\nwith `BlockAddID` ((#blockaddid-element)), or to the track as a whole\\nwith `BlockAddIDExtraData`.\" } }, { \"@name\": \"BlockAddIDValue\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\BlockAdditionMapping\\\\BlockAddIDValue\", \"@id\": \"0x41F0\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@range\": \">=2\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"If the track format extension needs content beside frames,\\nthe value refers to the `BlockAddID` ((#blockaddid-element)) value being described.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"To keep `MaxBlockAdditionID` as low as possible, small values **SHOULD** be used.\" }] }, { \"@name\": \"BlockAddIDName\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\BlockAdditionMapping\\\\BlockAddIDName\", \"@id\": \"0x41A4\", \"@type\": \"string\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A human-friendly name describing the type of `BlockAdditional` data,\\nas defined by the associated `Block Additional Mapping`.\" } }, { \"@name\": \"BlockAddIDType\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\BlockAdditionMapping\\\\BlockAddIDType\", \"@id\": \"0x41E7\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Stores the registered identifier of the `Block Additional Mapping`\\nto define how the `BlockAdditional` data should be handled.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"If `BlockAddIDType` is 0, the `BlockAddIDValue` and corresponding `BlockAddID` values **MUST** be 1.\" }] }, { \"@name\": \"BlockAddIDExtraData\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\BlockAdditionMapping\\\\BlockAddIDExtraData\", \"@id\": \"0x41ED\", \"@type\": \"binary\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Extra binary data that the `BlockAddIDType` can use to interpret the `BlockAdditional` data.\\nThe interpretation of the binary data depends on the `BlockAddIDType` value and the corresponding `Block Additional Mapping`.\" } }, { \"@name\": \"Name\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Name\", \"@id\": \"0x536E\", \"@type\": \"utf-8\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A human-readable track name.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"TrackName\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"Language\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Language\", \"@id\": \"0x22B59C\", \"@type\": \"string\", \"@default\": \"eng\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The language of the track,\\nin the Matroska languages form; see (#language-codes) on language codes.\\nThis element **MUST** be ignored if the `LanguageBCP47` element is used in the same `TrackEntry`.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"TrackLanguage\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"LanguageBCP47\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\LanguageBCP47\", \"@id\": \"0x22B59D\", \"@type\": \"string\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The language of the track,\\nin the form defined in [@!RFC5646]; see (#language-codes) on language codes.\\nIf this element is used, then any `Language` elements used in the same `TrackEntry` **MUST** be ignored.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"LanguageIETF\" } }, { \"@name\": \"CodecID\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\CodecID\", \"@id\": \"0x86\", \"@type\": \"string\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"An ID corresponding to the codec;\\nsee [@?I-D.ietf-cellar-codec] for more info.\" }, \"extension\": [{ \"@type\": \"stream copy\", \"@keep\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"CodecPrivate\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\CodecPrivate\", \"@id\": \"0x63A2\", \"@type\": \"binary\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Private data only known to the codec.\" }, \"extension\": [{ \"@type\": \"stream copy\", \"@keep\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"CodecName\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\CodecName\", \"@id\": \"0x258688\", \"@type\": \"utf-8\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A human-readable string specifying the codec.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"AttachmentLink\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\AttachmentLink\", \"@id\": \"0x7446\", \"@type\": \"uinteger\", \"@maxver\": \"3\", \"@range\": \"not 0\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The UID of an attachment that is used by this codec.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"The value **MUST** match the `FileUID` value of an attachment found in this `Segment`.\" }], \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"TrackAttachmentLink\" } }, { \"@name\": \"CodecSettings\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\CodecSettings\", \"@id\": \"0x3A9697\", \"@type\": \"utf-8\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A string describing the encoding setting used.\" } }, { \"@name\": \"CodecInfoURL\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\CodecInfoURL\", \"@id\": \"0x3B4040\", \"@type\": \"string\", \"@minver\": \"0\", \"@maxver\": \"0\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A URL to find information about the codec used.\" } }, { \"@name\": \"CodecDownloadURL\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\CodecDownloadURL\", \"@id\": \"0x26B240\", \"@type\": \"string\", \"@minver\": \"0\", \"@maxver\": \"0\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A URL to download information about the codec used.\" } }, { \"@name\": \"CodecDecodeAll\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\CodecDecodeAll\", \"@id\": \"0xAA\", \"@type\": \"uinteger\", \"@maxver\": \"0\", \"@range\": \"0-1\", \"@default\": \"1\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Set to 1 if the codec can decode potentially damaged data.\" } }, { \"@name\": \"TrackOverlay\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackOverlay\", \"@id\": \"0x6FAB\", \"@type\": \"uinteger\", \"@maxver\": \"0\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Specify that this track is an overlay track for the `Track` specified (in the u-integer).\\nThis means that when this track has a gap on `SilentTracks`, the overlay track should be used instead. The order of multiple `TrackOverlay` matters; the first one is the one that should be used.\\nIf the first one is not found, it should be the second, etc.\" } }, { \"@name\": \"CodecDelay\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\CodecDelay\", \"@id\": \"0x56AA\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The built-in delay for the codec, expressed in Matroska Ticks -- i.e., in nanoseconds; see (#timestamp-ticks).\\nIt represents the number of codec samples that will be discarded by the decoder during playback.\\nThis timestamp value **MUST** be subtracted from each frame timestamp in order to get the timestamp that will be actually played.\\nThe value **SHOULD** be small so the muxing of tracks with the same actual timestamp are in the same `Cluster`.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"SeekPreRoll\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\SeekPreRoll\", \"@id\": \"0x56BB\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"After a discontinuity, the duration of the data\\nthat the decoder **MUST** decode before the decoded data is valid, expressed in Matroska Ticks -- i.e., in nanoseconds; see (#timestamp-ticks).\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"TrackTranslate\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackTranslate\", \"@id\": \"0x6624\", \"@type\": \"master\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The mapping between this `TrackEntry` and a track value in the given Chapter Codec.\" }, { \"@lang\": \"en\", \"@purpose\": \"rationale\", \"#text\": \"Chapter Codecs may need to address content in a specific track, but they may not know of the way to identify tracks in Matroska.\\nThis element and its child elements add a way to map the internal tracks known to the Chapter Codec to the track IDs in Matroska.\\nThis allows remuxing a file with Chapter Codec without changing the content of the codec data, just the track mapping.\" }] }, { \"@name\": \"TrackTranslateTrackID\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackTranslate\\\\TrackTranslateTrackID\", \"@id\": \"0x66A5\", \"@type\": \"binary\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The binary value used to represent this `TrackEntry` in the chapter codec data.\\nThe format depends on the `ChapProcessCodecID` used; see (#chapprocesscodecid-element).\" } }, { \"@name\": \"TrackTranslateCodec\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackTranslate\\\\TrackTranslateCodec\", \"@id\": \"0x66BF\", \"@type\": \"uinteger\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Applies to the chapter codec of the given chapter edition(s); see (#chapprocesscodecid-element).\" }, \"extension\": { \"@type\": \"enum source\", \"@source\": \"Chapter Codec ID\" } }, { \"@name\": \"TrackTranslateEditionUID\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackTranslate\\\\TrackTranslateEditionUID\", \"@id\": \"0x66FC\", \"@type\": \"uinteger\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Specifies a chapter edition UID to which this `TrackTranslate` applies.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"When no `TrackTranslateEditionUID` is specified in the `TrackTranslate`, the `TrackTranslate` applies to all chapter editions found in the `Segment` using the given `TrackTranslateCodec`.\" }] }, { \"@name\": \"Video\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\", \"@id\": \"0xE0\", \"@type\": \"master\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Video settings.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"TrackVideo\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"FlagInterlaced\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\FlagInterlaced\", \"@id\": \"0x9A\", \"@type\": \"uinteger\", \"@minver\": \"2\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Specifies whether the video frames in this track are interlaced.\" }, \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"undetermined\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Unknown status.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"This value **SHOULD** be avoided.\" }] }, { \"@value\": \"1\", \"@label\": \"interlaced\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Interlaced frames.\" } }, { \"@value\": \"2\", \"@label\": \"progressive\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"No interlacing.\" } }] }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoFlagInterlaced\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"FieldOrder\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\FieldOrder\", \"@id\": \"0x9D\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@default\": \"2\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Specifies the field ordering of video frames in this track.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"If `FlagInterlaced` is not set to 1, this element **MUST** be ignored.\" }], \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"progressive\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Interlaced frames.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"This value **SHOULD** be avoided; setting `FlagInterlaced` to 2 is sufficient.\" }] }, { \"@value\": \"1\", \"@label\": \"tff\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Top field displayed first. Top field stored first.\" } }, { \"@value\": \"2\", \"@label\": \"undetermined\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Unknown field order.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"This value **SHOULD** be avoided.\" }] }, { \"@value\": \"6\", \"@label\": \"bff\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Bottom field displayed first. Bottom field stored first.\" } }, { \"@value\": \"9\", \"@label\": \"tff (interleaved)\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Top field displayed first. Fields are interleaved in storage with the top line of the top field stored first.\" } }, { \"@value\": \"14\", \"@label\": \"bff (interleaved)\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Bottom field displayed first. Fields are interleaved in storage with the top line of the top field stored first.\" } }] }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"VideoFieldOrder\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"StereoMode\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\StereoMode\", \"@id\": \"0x53B8\", \"@type\": \"uinteger\", \"@minver\": \"3\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Stereo-3D video mode. See (#multi-planar-and-3d-videos) for more details.\" }, \"extension\": [{ \"@type\": \"enum source\", \"@registry\": \"Stereo Mode\", \"@policy\": \"Specification Required\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoStereoMode\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }], \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"mono\" }, { \"@value\": \"1\", \"@label\": \"side by side (left eye first)\" }, { \"@value\": \"2\", \"@label\": \"top - bottom (right eye is first)\" }, { \"@value\": \"3\", \"@label\": \"top - bottom (left eye is first)\" }, { \"@value\": \"4\", \"@label\": \"checkboard (right eye is first)\" }, { \"@value\": \"5\", \"@label\": \"checkboard (left eye is first)\" }, { \"@value\": \"6\", \"@label\": \"row interleaved (right eye is first)\" }, { \"@value\": \"7\", \"@label\": \"row interleaved (left eye is first)\" }, { \"@value\": \"8\", \"@label\": \"column interleaved (right eye is first)\" }, { \"@value\": \"9\", \"@label\": \"column interleaved (left eye is first)\" }, { \"@value\": \"10\", \"@label\": \"anaglyph (cyan/red)\" }, { \"@value\": \"11\", \"@label\": \"side by side (right eye first)\" }, { \"@value\": \"12\", \"@label\": \"anaglyph (green/magenta)\" }, { \"@value\": \"13\", \"@label\": \"both eyes laced in one Block (left eye is first)\" }, { \"@value\": \"14\", \"@label\": \"both eyes laced in one Block (right eye is first)\" }] } }, { \"@name\": \"AlphaMode\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\AlphaMode\", \"@id\": \"0x53C0\", \"@type\": \"uinteger\", \"@minver\": \"3\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Indicates whether the `BlockAdditional` element with `BlockAddID` of \\\"1\\\"\\n contains Alpha data as defined by the Codec Mapping for the `CodecID`.\\n Undefined values (i.e., values other than 0 or 1) **SHOULD NOT** be used, as the\\n behavior of known implementations is different.\" }, \"extension\": [{ \"@type\": \"enum source\", \"@registry\": \"Alpha Mode\", \"@policy\": \"First Come First Served\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoAlphaMode\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }], \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"none\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `BlockAdditional` element with `BlockAddID` of \\\"1\\\" does not exist or **SHOULD NOT** be considered as containing such data.\" } }, { \"@value\": \"1\", \"@label\": \"present\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `BlockAdditional` element with `BlockAddID` of \\\"1\\\" contains alpha channel data.\" } }] } }, { \"@name\": \"OldStereoMode\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\OldStereoMode\", \"@id\": \"0x53B9\", \"@type\": \"uinteger\", \"@maxver\": \"2\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Bogus `StereoMode` value used in old versions of [@?libmatroska].\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"This element **MUST NOT** be used. It was an incorrect value used in libmatroska up to 0.9.0.\" }], \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"mono\" }, { \"@value\": \"1\", \"@label\": \"right eye\" }, { \"@value\": \"2\", \"@label\": \"left eye\" }, { \"@value\": \"3\", \"@label\": \"both eyes\" }] } }, { \"@name\": \"PixelWidth\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\PixelWidth\", \"@id\": \"0xB0\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Width of the encoded video frames in pixels.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"VideoPixelWidth\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"PixelHeight\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\PixelHeight\", \"@id\": \"0xBA\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Height of the encoded video frames in pixels.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"VideoPixelHeight\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"PixelCropBottom\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\PixelCropBottom\", \"@id\": \"0x54AA\", \"@type\": \"uinteger\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The number of video pixels to remove at the bottom of the image.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"VideoPixelCropBottom\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"PixelCropTop\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\PixelCropTop\", \"@id\": \"0x54BB\", \"@type\": \"uinteger\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The number of video pixels to remove at the top of the image.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"VideoPixelCropTop\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"PixelCropLeft\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\PixelCropLeft\", \"@id\": \"0x54CC\", \"@type\": \"uinteger\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The number of video pixels to remove on the left of the image.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"VideoPixelCropLeft\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"PixelCropRight\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\PixelCropRight\", \"@id\": \"0x54DD\", \"@type\": \"uinteger\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The number of video pixels to remove on the right of the image.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"VideoPixelCropRight\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"DisplayWidth\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\DisplayWidth\", \"@id\": \"0x54B0\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Width of the video frames to display. Applies to the video frame after cropping (PixelCrop* Elements).\" }, \"implementation_note\": { \"@note_attribute\": \"default\", \"#text\": \"If the DisplayUnit of the same `TrackEntry` is 0, then the default value for `DisplayWidth` is equal to `PixelWidth` - `PixelCropLeft` - `PixelCropRight`; else, there is no default value.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"VideoDisplayWidth\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"DisplayHeight\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\DisplayHeight\", \"@id\": \"0x54BA\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Height of the video frames to display. Applies to the video frame after cropping (PixelCrop* Elements).\" }, \"implementation_note\": { \"@note_attribute\": \"default\", \"#text\": \"If the DisplayUnit of the same `TrackEntry` is 0, then the default value for `DisplayHeight` is equal to `PixelHeight` - `PixelCropTop` - `PixelCropBottom`; else, there is no default value.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"VideoDisplayHeight\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"DisplayUnit\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\DisplayUnit\", \"@id\": \"0x54B2\", \"@type\": \"uinteger\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"How `DisplayWidth` and `DisplayHeight` are interpreted.\" }, \"extension\": [{ \"@type\": \"enum source\", \"@registry\": \"Display Unit\", \"@policy\": \"Specification Required\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoDisplayUnit\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }], \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"pixels\" }, { \"@value\": \"1\", \"@label\": \"centimeters\" }, { \"@value\": \"2\", \"@label\": \"inches\" }, { \"@value\": \"3\", \"@label\": \"display aspect ratio\" }, { \"@value\": \"4\", \"@label\": \"unknown\" }] } }, { \"@name\": \"AspectRatioType\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\AspectRatioType\", \"@id\": \"0x54B3\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@default\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Specifies the possible modifications to the aspect ratio.\" }, \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"free resizing\" }, { \"@value\": \"1\", \"@label\": \"keep aspect ratio\" }, { \"@value\": \"2\", \"@label\": \"fixed\" }] }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"VideoAspectRatio\" } }, { \"@name\": \"UncompressedFourCC\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\UncompressedFourCC\", \"@id\": \"0x2EB524\", \"@type\": \"binary\", \"@length\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Specifies the uncompressed pixel format used for the `Track`'s data as a FourCC.\\nThis value is similar in scope to the biCompression value of AVI's `BITMAPINFO` [@?AVIFormat]. There is neither a definitive list of FourCC values nor an official registry. Some common values for YUV pixel formats can be found at [@?MSYUV8], [@?MSYUV16], and [@?FourCC-YUV]. Some common values for uncompressed RGB pixel formats can be found at [@?MSRGB] and [@?FourCC-RGB].\" }, \"implementation_note\": { \"@note_attribute\": \"minOccurs\", \"#text\": \"UncompressedFourCC **MUST** be set (minOccurs=1) in `TrackEntry` when the `CodecID` element of the `TrackEntry` is set to \\\"V_UNCOMPRESSED\\\".\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"VideoColourSpace\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"GammaValue\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\GammaValue\", \"@id\": \"0x2FB523\", \"@type\": \"float\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@range\": \"> 0x0p+0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Gamma value.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"VideoGamma\" } }, { \"@name\": \"FrameRate\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\FrameRate\", \"@id\": \"0x2383E3\", \"@type\": \"float\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@range\": \"> 0x0p+0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Number of frames per second. This value is informational only. It is intended for constant frame rate streams and should not be\\n used for a variable frame rate `TrackEntry`.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"VideoFrameRate\" } }, { \"@name\": \"Colour\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\", \"@id\": \"0x55B0\", \"@type\": \"master\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Settings describing the color format.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoColour\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"MatrixCoefficients\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\MatrixCoefficients\", \"@id\": \"0x55B1\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@default\": \"2\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The Matrix Coefficients of the video used to derive luma and chroma values from red, green, and blue color primaries.\\nFor clarity, the value and meanings for `MatrixCoefficients` are adopted from Table 4 of [@!ITU-H.273].\" }, \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"Identity\" }, { \"@value\": \"1\", \"@label\": \"ITU-R BT.709\" }, { \"@value\": \"2\", \"@label\": \"unspecified\" }, { \"@value\": \"3\", \"@label\": \"reserved\" }, { \"@value\": \"4\", \"@label\": \"US FCC 73.682\" }, { \"@value\": \"5\", \"@label\": \"ITU-R BT.470BG\" }, { \"@value\": \"6\", \"@label\": \"SMPTE 170M\" }, { \"@value\": \"7\", \"@label\": \"SMPTE 240M\" }, { \"@value\": \"8\", \"@label\": \"YCoCg\" }, { \"@value\": \"9\", \"@label\": \"BT2020 Non-constant Luminance\" }, { \"@value\": \"10\", \"@label\": \"BT2020 Constant Luminance\" }, { \"@value\": \"11\", \"@label\": \"SMPTE ST 2085\" }, { \"@value\": \"12\", \"@label\": \"Chroma-derived Non-constant Luminance\" }, { \"@value\": \"13\", \"@label\": \"Chroma-derived Constant Luminance\" }, { \"@value\": \"14\", \"@label\": \"ITU-R BT.2100-0\" }] }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoColourMatrix\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"BitsPerChannel\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\BitsPerChannel\", \"@id\": \"0x55B2\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Number of decoded bits per channel. A value of 0 indicates that the `BitsPerChannel` is unspecified.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoBitsPerChannel\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"ChromaSubsamplingHorz\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\ChromaSubsamplingHorz\", \"@id\": \"0x55B3\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The number of pixels to remove in the Cr and Cb channels for every pixel not removed horizontally. Example: For video with 4:2:0 chroma subsampling, the `ChromaSubsamplingHorz`\\n **SHOULD** be set to 1.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoChromaSubsampHorz\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"ChromaSubsamplingVert\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\ChromaSubsamplingVert\", \"@id\": \"0x55B4\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The number of pixels to remove in the Cr and Cb channels for every pixel not removed vertically.\\nExample: For video with 4:2:0 chroma subsampling, the `ChromaSubsamplingVert`\\n**SHOULD** be set to 1.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoChromaSubsampVert\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"CbSubsamplingHorz\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\CbSubsamplingHorz\", \"@id\": \"0x55B5\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The number of pixels to remove in the Cb channel for every pixel not removed horizontally.\\nThis is additive with `ChromaSubsamplingHorz`.\\nExample: For video with 4:2:1 chroma\\nsubsampling, the `ChromaSubsamplingHorz` **SHOULD** be set to 1, and `CbSubsamplingHorz` **SHOULD** be set to 1.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoCbSubsampHorz\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"CbSubsamplingVert\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\CbSubsamplingVert\", \"@id\": \"0x55B6\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The number of pixels to remove in the Cb channel for every pixel not removed vertically.\\nThis is additive with `ChromaSubsamplingVert`.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoCbSubsampVert\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"ChromaSitingHorz\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\ChromaSitingHorz\", \"@id\": \"0x55B7\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"How chroma is subsampled horizontally.\" }, \"extension\": [{ \"@type\": \"enum source\", \"@registry\": \"Horizontal Chroma Siting\", \"@policy\": \"First Come First Served\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoChromaSitHorz\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }], \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"unspecified\" }, { \"@value\": \"1\", \"@label\": \"left collocated\" }, { \"@value\": \"2\", \"@label\": \"half\" }] } }, { \"@name\": \"ChromaSitingVert\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\ChromaSitingVert\", \"@id\": \"0x55B8\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"How chroma is subsampled vertically.\" }, \"extension\": [{ \"@type\": \"enum source\", \"@registry\": \"Vertical Chroma Siting\", \"@policy\": \"First Come First Served\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoChromaSitVert\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }], \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"unspecified\" }, { \"@value\": \"1\", \"@label\": \"top collocated\" }, { \"@value\": \"2\", \"@label\": \"half\" }] } }, { \"@name\": \"Range\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\Range\", \"@id\": \"0x55B9\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Clipping of the color ranges.\" }, \"extension\": [{ \"@type\": \"enum source\", \"@registry\": \"Color Range\", \"@policy\": \"Specification Required\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoColourRange\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }], \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"unspecified\" }, { \"@value\": \"1\", \"@label\": \"broadcast range\" }, { \"@value\": \"2\", \"@label\": \"full range (no clipping)\" }, { \"@value\": \"3\", \"@label\": \"defined by MatrixCoefficients / TransferCharacteristics\" }] } }, { \"@name\": \"TransferCharacteristics\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\TransferCharacteristics\", \"@id\": \"0x55BA\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@default\": \"2\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The transfer characteristics of the video. For clarity,\\nthe value and meanings for `TransferCharacteristics` are adopted from Table 3 of [@!ITU-H.273].\" }, \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"reserved\" }, { \"@value\": \"1\", \"@label\": \"ITU-R BT.709\" }, { \"@value\": \"2\", \"@label\": \"unspecified\" }, { \"@value\": \"3\", \"@label\": \"reserved2\" }, { \"@value\": \"4\", \"@label\": \"Gamma 2.2 curve - BT.470M\" }, { \"@value\": \"5\", \"@label\": \"Gamma 2.8 curve - BT.470BG\" }, { \"@value\": \"6\", \"@label\": \"SMPTE 170M\" }, { \"@value\": \"7\", \"@label\": \"SMPTE 240M\" }, { \"@value\": \"8\", \"@label\": \"Linear\" }, { \"@value\": \"9\", \"@label\": \"Log\" }, { \"@value\": \"10\", \"@label\": \"Log Sqrt\" }, { \"@value\": \"11\", \"@label\": \"IEC 61966-2-4\" }, { \"@value\": \"12\", \"@label\": \"ITU-R BT.1361 Extended Colour Gamut\" }, { \"@value\": \"13\", \"@label\": \"IEC 61966-2-1\" }, { \"@value\": \"14\", \"@label\": \"ITU-R BT.2020 10 bit\" }, { \"@value\": \"15\", \"@label\": \"ITU-R BT.2020 12 bit\" }, { \"@value\": \"16\", \"@label\": \"ITU-R BT.2100 Perceptual Quantization\" }, { \"@value\": \"17\", \"@label\": \"SMPTE ST 428-1\" }, { \"@value\": \"18\", \"@label\": \"ARIB STD-B67 (HLG)\" }] }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoColourTransferCharacter\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"Primaries\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\Primaries\", \"@id\": \"0x55BB\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@default\": \"2\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The color primaries of the video. For clarity,\\nthe value and meanings for `Primaries` are adopted from Table 2 of [@!ITU-H.273].\" }, \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"reserved\" }, { \"@value\": \"1\", \"@label\": \"ITU-R BT.709\" }, { \"@value\": \"2\", \"@label\": \"unspecified\" }, { \"@value\": \"3\", \"@label\": \"reserved2\" }, { \"@value\": \"4\", \"@label\": \"ITU-R BT.470M\" }, { \"@value\": \"5\", \"@label\": \"ITU-R BT.470BG - BT.601 625\" }, { \"@value\": \"6\", \"@label\": \"ITU-R BT.601 525 - SMPTE 170M\" }, { \"@value\": \"7\", \"@label\": \"SMPTE 240M\" }, { \"@value\": \"8\", \"@label\": \"FILM\" }, { \"@value\": \"9\", \"@label\": \"ITU-R BT.2020\" }, { \"@value\": \"10\", \"@label\": \"SMPTE ST 428-1\" }, { \"@value\": \"11\", \"@label\": \"SMPTE RP 432-2\" }, { \"@value\": \"12\", \"@label\": \"SMPTE EG 432-2\" }, { \"@value\": \"22\", \"@label\": \"EBU Tech. 3213-E - JEDEC P22 phosphors\" }] }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoColourPrimaries\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"MaxCLL\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\MaxCLL\", \"@id\": \"0x55BC\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Maximum brightness of a single pixel (Maximum Content Light Level)\\nin candelas per square meter (cd/m^2^).\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoColourMaxCLL\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"MaxFALL\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\MaxFALL\", \"@id\": \"0x55BD\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Maximum brightness of a single full frame (Maximum Frame-Average Light Level)\\nin candelas per square meter (cd/m^2^).\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoColourMaxFALL\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"MasteringMetadata\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\MasteringMetadata\", \"@id\": \"0x55D0\", \"@type\": \"master\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"SMPTE 2086 mastering data.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoColourMasterMeta\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"PrimaryRChromaticityX\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\MasteringMetadata\\\\PrimaryRChromaticityX\", \"@id\": \"0x55D1\", \"@type\": \"float\", \"@minver\": \"4\", \"@range\": \"0x0p+0-0x1p+0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Red X chromaticity coordinate, as defined by [@!CIE-1931].\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoRChromaX\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"PrimaryRChromaticityY\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\MasteringMetadata\\\\PrimaryRChromaticityY\", \"@id\": \"0x55D2\", \"@type\": \"float\", \"@minver\": \"4\", \"@range\": \"0x0p+0-0x1p+0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Red Y chromaticity coordinate, as defined by [@!CIE-1931].\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoRChromaY\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"PrimaryGChromaticityX\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\MasteringMetadata\\\\PrimaryGChromaticityX\", \"@id\": \"0x55D3\", \"@type\": \"float\", \"@minver\": \"4\", \"@range\": \"0x0p+0-0x1p+0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Green X chromaticity coordinate, as defined by [@!CIE-1931].\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoGChromaX\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"PrimaryGChromaticityY\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\MasteringMetadata\\\\PrimaryGChromaticityY\", \"@id\": \"0x55D4\", \"@type\": \"float\", \"@minver\": \"4\", \"@range\": \"0x0p+0-0x1p+0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Green Y chromaticity coordinate, as defined by [@!CIE-1931].\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoGChromaY\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"PrimaryBChromaticityX\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\MasteringMetadata\\\\PrimaryBChromaticityX\", \"@id\": \"0x55D5\", \"@type\": \"float\", \"@minver\": \"4\", \"@range\": \"0x0p+0-0x1p+0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Blue X chromaticity coordinate, as defined by [@!CIE-1931].\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoBChromaX\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"PrimaryBChromaticityY\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\MasteringMetadata\\\\PrimaryBChromaticityY\", \"@id\": \"0x55D6\", \"@type\": \"float\", \"@minver\": \"4\", \"@range\": \"0x0p+0-0x1p+0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Blue Y chromaticity coordinate, as defined by [@!CIE-1931].\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoBChromaY\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"WhitePointChromaticityX\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\MasteringMetadata\\\\WhitePointChromaticityX\", \"@id\": \"0x55D7\", \"@type\": \"float\", \"@minver\": \"4\", \"@range\": \"0x0p+0-0x1p+0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"White X chromaticity coordinate, as defined by [@!CIE-1931].\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoWhitePointChromaX\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"WhitePointChromaticityY\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\MasteringMetadata\\\\WhitePointChromaticityY\", \"@id\": \"0x55D8\", \"@type\": \"float\", \"@minver\": \"4\", \"@range\": \"0x0p+0-0x1p+0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"White Y chromaticity coordinate, as defined by [@!CIE-1931].\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoWhitePointChromaY\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"LuminanceMax\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\MasteringMetadata\\\\LuminanceMax\", \"@id\": \"0x55D9\", \"@type\": \"float\", \"@minver\": \"4\", \"@range\": \">= 0x0p+0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Maximum luminance. Represented in candelas per square meter (cd/m^2^).\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoLuminanceMax\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"LuminanceMin\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Colour\\\\MasteringMetadata\\\\LuminanceMin\", \"@id\": \"0x55DA\", \"@type\": \"float\", \"@minver\": \"4\", \"@range\": \">= 0x0p+0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Minimum luminance. Represented in candelas per square meter (cd/m^2^).\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoLuminanceMin\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"Projection\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Projection\", \"@id\": \"0x7670\", \"@type\": \"master\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Describes the video projection details. Used to render spherical or VR videos or to flip videos horizontally or vertically.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoProjection\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"ProjectionType\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Projection\\\\ProjectionType\", \"@id\": \"0x7671\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Describes the projection used for this video track.\" }, \"extension\": [{ \"@type\": \"enum source\", \"@registry\": \"Projection Type\", \"@policy\": \"First Come First Served\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoProjectionType\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }], \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"rectangular\" }, { \"@value\": \"1\", \"@label\": \"equirectangular\" }, { \"@value\": \"2\", \"@label\": \"cubemap\" }, { \"@value\": \"3\", \"@label\": \"mesh\" }] } }, { \"@name\": \"ProjectionPrivate\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Projection\\\\ProjectionPrivate\", \"@id\": \"0x7672\", \"@type\": \"binary\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Private data that only applies to a specific projection.\\n* If `ProjectionType` equals 0 (rectangular),\\n then this element **MUST NOT** be present.\\n* If `ProjectionType` equals 1 (equirectangular), then this element **MUST** be present and contain the same binary data that would be stored inside\\n an ISOBMFF Equirectangular Projection Box (\\\"equi\\\").\\n* If `ProjectionType` equals 2 (cubemap), then this element **MUST** be present and contain the same binary data that would be stored\\n inside an ISOBMFF Cubemap Projection Box (\\\"cbmp\\\").\\n* If `ProjectionType` equals 3 (mesh), then this element **MUST** be present and contain the same binary data that would be stored inside\\n an ISOBMFF Mesh Projection Box (\\\"mshp\\\").\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"ISOBMFF box size and FourCC fields are not included in the binary data,\\nbut the FullBox version and flag fields are. This is to avoid\\nredundant framing information while preserving versioning and semantics between the two container formats.\" }], \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoProjectionPrivate\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"ProjectionPoseYaw\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Projection\\\\ProjectionPoseYaw\", \"@id\": \"0x7673\", \"@type\": \"float\", \"@minver\": \"4\", \"@range\": \">= -0xB4p+0, <= 0xB4p+0\", \"@default\": \"0x0p+0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Specifies a yaw rotation to the projection. Value represents a clockwise rotation, in degrees, around the up vector. This rotation must be applied\\nbefore any `ProjectionPosePitch` or `ProjectionPoseRoll` rotations.\\nThe value of this element **MUST** be in the -180 to 180 degree range, both inclusive.\\n\\nSetting `ProjectionPoseYaw` to 180 or -180 degrees with `ProjectionPoseRoll` and `ProjectionPosePitch` set to 0 degrees flips the image horizontally.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoProjectionPoseYaw\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"ProjectionPosePitch\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Projection\\\\ProjectionPosePitch\", \"@id\": \"0x7674\", \"@type\": \"float\", \"@minver\": \"4\", \"@range\": \">= -0x5Ap+0, <= 0x5Ap+0\", \"@default\": \"0x0p+0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Specifies a pitch rotation to the projection. Value represents a counter-clockwise rotation, in degrees, around the right vector. This rotation must be applied\\nafter the `ProjectionPoseYaw` rotation and before the `ProjectionPoseRoll` rotation.\\nThe value of this element **MUST** be in the -90 to 90 degree range, both inclusive.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoProjectionPosePitch\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"ProjectionPoseRoll\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Video\\\\Projection\\\\ProjectionPoseRoll\", \"@id\": \"0x7675\", \"@type\": \"float\", \"@minver\": \"4\", \"@range\": \">= -0xB4p+0, <= 0xB4p+0\", \"@default\": \"0x0p+0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Specifies a roll rotation to the projection. Value represents a\\n counter-clockwise rotation, in degrees, around the forward vector. This\\n rotation must be applied after the `ProjectionPoseYaw` and\\n `ProjectionPosePitch` rotations. The value of this element\\n **MUST** be in the -180 to 180 degree range, both inclusive. Setting `ProjectionPoseRoll` to 180 or -180 degrees and\\n `ProjectionPoseYaw` to 180 or -180 degrees with\\n `ProjectionPosePitch` set to 0 degrees flips the image vertically.\\n Setting `ProjectionPoseRoll` to 180 or -180 degrees with\\n `ProjectionPoseYaw` and `ProjectionPosePitch` set to 0 degrees\\n flips the image horizontally and vertically.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"VideoProjectionPoseRoll\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"Audio\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Audio\", \"@id\": \"0xE1\", \"@type\": \"master\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Audio settings.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"TrackAudio\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"SamplingFrequency\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Audio\\\\SamplingFrequency\", \"@id\": \"0xB5\", \"@type\": \"float\", \"@range\": \"> 0x0p+0\", \"@default\": \"0x1.f4p+12\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Sampling frequency in Hz.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"AudioSamplingFreq\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"OutputSamplingFrequency\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Audio\\\\OutputSamplingFrequency\", \"@id\": \"0x78B5\", \"@type\": \"float\", \"@range\": \"> 0x0p+0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Real output sampling frequency in Hz that is used for Spectral Band Replication (SBR) techniques.\" }, \"implementation_note\": { \"@note_attribute\": \"default\", \"#text\": \"The default value for `OutputSamplingFrequency` of the same `TrackEntry` is equal to the `SamplingFrequency`.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"AudioOutputSamplingFreq\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"Channels\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Audio\\\\Channels\", \"@id\": \"0x9F\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@default\": \"1\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Numbers of channels in the track.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"AudioChannels\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"ChannelPositions\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Audio\\\\ChannelPositions\", \"@id\": \"0x7D7B\", \"@type\": \"binary\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Table of horizontal angles for each successive channel.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"AudioPosition\" } }, { \"@name\": \"BitDepth\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Audio\\\\BitDepth\", \"@id\": \"0x6264\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Bits per sample, mostly used for PCM.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"AudioBitDepth\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }] }, { \"@name\": \"Emphasis\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\Audio\\\\Emphasis\", \"@id\": \"0x52F1\", \"@type\": \"uinteger\", \"@minver\": \"5\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Audio emphasis applied on audio samples. The player **MUST** apply the inverse emphasis to get the proper audio samples.\" }, \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"No emphasis\" }, { \"@value\": \"1\", \"@label\": \"CD audio\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"First order filter with zero point at 50 microseconds and a pole at 15 microseconds. Also found on DVD Audio and MPEG audio.\" } }, { \"@value\": \"2\", \"@label\": \"reserved\" }, { \"@value\": \"3\", \"@label\": \"CCIT J.17\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Defined in [@!ITU-J.17].\" } }, { \"@value\": \"4\", \"@label\": \"FM 50\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"FM Radio in Europe. RC Filter with a time constant of 50 microseconds.\" } }, { \"@value\": \"5\", \"@label\": \"FM 75\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"FM Radio in the USA. RC Filter with a time constant of 75 microseconds.\" } }, { \"@value\": \"10\", \"@label\": \"Phono RIAA\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Phono filter with time constants of t1=3180, t2=318 and t3=75 microseconds. [@!NAB1964]\" } }, { \"@value\": \"11\", \"@label\": \"Phono IEC N78\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Phono filter with time constants of t1=3180, t2=450 and t3=50 microseconds.\" } }, { \"@value\": \"12\", \"@label\": \"Phono TELDEC\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Phono filter with time constants of t1=3180, t2=318 and t3=50 microseconds.\" } }, { \"@value\": \"13\", \"@label\": \"Phono EMI\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Phono filter with time constants of t1=2500, t2=500 and t3=70 microseconds.\" } }, { \"@value\": \"14\", \"@label\": \"Phono Columbia LP\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Phono filter with time constants of t1=1590, t2=318 and t3=100 microseconds.\" } }, { \"@value\": \"15\", \"@label\": \"Phono LONDON\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Phono filter with time constants of t1=1590, t2=318 and t3=50 microseconds.\" } }, { \"@value\": \"16\", \"@label\": \"Phono NARTB\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Phono filter with time constants of t1=3180, t2=318 and t3=100 microseconds.\" } }] }, \"extension\": { \"@type\": \"stream copy\", \"@keep\": \"1\" } }, { \"@name\": \"TrackOperation\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackOperation\", \"@id\": \"0xE2\", \"@type\": \"master\", \"@minver\": \"3\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Operation that needs to be applied on tracks to create this virtual track. For more details, see (#track-operation).\" }, \"extension\": { \"@type\": \"stream copy\", \"@keep\": \"1\" } }, { \"@name\": \"TrackCombinePlanes\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackOperation\\\\TrackCombinePlanes\", \"@id\": \"0xE3\", \"@type\": \"master\", \"@minver\": \"3\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains the list of all video plane tracks that need to be combined to create this 3D track.\" }, \"extension\": { \"@type\": \"stream copy\", \"@keep\": \"1\" } }, { \"@name\": \"TrackPlane\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackOperation\\\\TrackCombinePlanes\\\\TrackPlane\", \"@id\": \"0xE4\", \"@type\": \"master\", \"@minver\": \"3\", \"@minOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains a video plane track that needs to be combined to create this 3D track.\" }, \"extension\": { \"@type\": \"stream copy\", \"@keep\": \"1\" } }, { \"@name\": \"TrackPlaneUID\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackOperation\\\\TrackCombinePlanes\\\\TrackPlane\\\\TrackPlaneUID\", \"@id\": \"0xE5\", \"@type\": \"uinteger\", \"@minver\": \"3\", \"@range\": \"not 0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `TrackUID` number of the track representing the plane.\" }, \"extension\": { \"@type\": \"stream copy\", \"@keep\": \"1\" } }, { \"@name\": \"TrackPlaneType\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackOperation\\\\TrackCombinePlanes\\\\TrackPlane\\\\TrackPlaneType\", \"@id\": \"0xE6\", \"@type\": \"uinteger\", \"@minver\": \"3\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The kind of plane this track corresponds to.\" }, \"extension\": [{ \"@type\": \"enum source\", \"@registry\": \"Track Plane Type\", \"@policy\": \"First Come First Served\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }], \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"left eye\" }, { \"@value\": \"1\", \"@label\": \"right eye\" }, { \"@value\": \"2\", \"@label\": \"background\" }] } }, { \"@name\": \"TrackJoinBlocks\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackOperation\\\\TrackJoinBlocks\", \"@id\": \"0xE9\", \"@type\": \"master\", \"@minver\": \"3\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains the list of all tracks whose `Blocks` need to be combined to create this virtual track.\" }, \"extension\": { \"@type\": \"stream copy\", \"@keep\": \"1\" } }, { \"@name\": \"TrackJoinUID\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrackOperation\\\\TrackJoinBlocks\\\\TrackJoinUID\", \"@id\": \"0xED\", \"@type\": \"uinteger\", \"@minver\": \"3\", \"@range\": \"not 0\", \"@minOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `TrackUID` number of a track whose blocks are used to create this virtual track.\" }, \"extension\": { \"@type\": \"stream copy\", \"@keep\": \"1\" } }, { \"@name\": \"TrickTrackUID\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrickTrackUID\", \"@id\": \"0xC0\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `TrackUID` of the Smooth FF/RW video in the paired EBML structure corresponding to this video track. See [@?DivXTrickTrack].\" }, \"extension\": { \"@type\": \"divx.com\", \"@divx\": \"1\" } }, { \"@name\": \"TrickTrackSegmentUID\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrickTrackSegmentUID\", \"@id\": \"0xC1\", \"@type\": \"binary\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@length\": \"16\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `SegmentUUID` of the `Segment` containing the track identified by TrickTrackUID. See [@?DivXTrickTrack].\" }, \"extension\": { \"@type\": \"divx.com\", \"@divx\": \"1\" } }, { \"@name\": \"TrickTrackFlag\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrickTrackFlag\", \"@id\": \"0xC6\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@default\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Set to 1 if this video track is a Smooth FF/RW track. If set to 1, `MasterTrackUID` and `MasterTrackSegUID` should be present, and\\n `BlockGroups` for this track must contain ReferenceFrame structures.\\nOtherwise, TrickTrackUID and TrickTrackSegUID must be present if this track has a corresponding Smooth FF/RW track. See [@?DivXTrickTrack].\" }, \"extension\": { \"@type\": \"divx.com\", \"@divx\": \"1\" } }, { \"@name\": \"TrickMasterTrackUID\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrickMasterTrackUID\", \"@id\": \"0xC7\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `TrackUID` of the video track in the paired EBML structure that corresponds to this Smooth FF/RW track. See [@?DivXTrickTrack].\" }, \"extension\": { \"@type\": \"divx.com\", \"@divx\": \"1\" } }, { \"@name\": \"TrickMasterTrackSegmentUID\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\TrickMasterTrackSegmentUID\", \"@id\": \"0xC4\", \"@type\": \"binary\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@length\": \"16\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `SegmentUUID` of the `Segment` containing the track identified by MasterTrackUID. See [@?DivXTrickTrack].\" }, \"extension\": { \"@type\": \"divx.com\", \"@divx\": \"1\" } }, { \"@name\": \"ContentEncodings\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\", \"@id\": \"0x6D80\", \"@type\": \"master\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Settings for several content encoding mechanisms like compression or encryption.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"ContentEncoding\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\\\\ContentEncoding\", \"@id\": \"0x6240\", \"@type\": \"master\", \"@minOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Settings for one content encoding like compression or encryption.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"ContentEncodingOrder\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\\\\ContentEncoding\\\\ContentEncodingOrder\", \"@id\": \"0x5031\", \"@type\": \"uinteger\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Defines the order to apply each `ContentEncoding` of the `ContentEncodings`.\\nThe decoder/demuxer **MUST** start with the `ContentEncoding` with the highest `ContentEncodingOrder` and work its way down to the `ContentEncoding` with the lowest `ContentEncodingOrder`.\\nThis value **MUST** be unique for each `ContentEncoding` found in the `ContentEncodings` of this `TrackEntry`.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"ContentEncodingScope\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\\\\ContentEncoding\\\\ContentEncodingScope\", \"@id\": \"0x5032\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@default\": \"1\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A bit field that describes which elements have been modified in this way. Values (big-endian) can be OR'ed.\" }, \"extension\": [{ \"@type\": \"enum source\", \"@registry\": \"Content Encoding Scope\", \"@policy\": \"Specification Required\", \"@bitfield\": \"1\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }], \"restriction\": { \"enum\": [{ \"@value\": \"0x1\", \"@label\": \"Block\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"All frame contents, excluding lacing data.\" } }, { \"@value\": \"0x2\", \"@label\": \"Private\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The track's `CodecPrivate` data.\" } }, { \"@value\": \"0x4\", \"@label\": \"Next\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The next ContentEncoding (next `ContentEncodingOrder`; the data inside `ContentCompression` and/or `ContentEncryption`).\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"This value **SHOULD NOT** be used, as it's not supported by players.\" }] }] } }, { \"@name\": \"ContentEncodingType\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\\\\ContentEncoding\\\\ContentEncodingType\", \"@id\": \"0x5033\", \"@type\": \"uinteger\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A value describing the kind of transformation that is applied.\" }, \"extension\": [{ \"@type\": \"enum source\", \"@registry\": \"Content Encoding Type\", \"@policy\": \"Specification Required\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }], \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"Compression\" }, { \"@value\": \"1\", \"@label\": \"Encryption\" }] } }, { \"@name\": \"ContentCompression\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\\\\ContentEncoding\\\\ContentCompression\", \"@id\": \"0x5034\", \"@type\": \"master\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Settings describing the compression used.\\nThis element **MUST** be present if the value of `ContentEncodingType` is 0 and absent otherwise.\\nEach block **MUST** be decompressable, even if no previous block is available in order to not prevent seeking.\" }, \"extension\": { \"@type\": \"stream copy\", \"@keep\": \"1\" } }, { \"@name\": \"ContentCompAlgo\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\\\\ContentEncoding\\\\ContentCompression\\\\ContentCompAlgo\", \"@id\": \"0x4254\", \"@type\": \"uinteger\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The compression algorithm used.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"Compression method \\\"1\\\" (bzlib) and \\\"2\\\" (lzo1x) lack proper documentation on the format, which limits implementation possibilities. Due to licensing conflicts on commonly available libraries' compression methods, \\\"2\\\" (lzo1x) does not offer widespread interoperability. A `Matroska Writer` **SHOULD NOT** use these compression methods by default. A `Matroska Reader` **MAY** support methods \\\"1\\\" and \\\"2\\\" and **SHOULD** support other methods.\" }], \"extension\": [{ \"@type\": \"enum source\", \"@registry\": \"Compression Algorithm\", \"@policy\": \"Specification Required\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }], \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"zlib\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"zlib compression [@!RFC1950].\" } }, { \"@value\": \"1\", \"@label\": \"bzlib\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"bzip2 compression [@?BZIP2] **SHOULD NOT** be used; see usage notes.\" } }, { \"@value\": \"2\", \"@label\": \"lzo1x\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Lempel-Ziv-Oberhumer compression [@?LZO] **SHOULD NOT** be used; see usage notes.\" } }, { \"@value\": \"3\", \"@label\": \"Header Stripping\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Octets in `ContentCompSettings` ((#contentcompsettings-element)) have been stripped from each frame.\" } }] } }, { \"@name\": \"ContentCompSettings\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\\\\ContentEncoding\\\\ContentCompression\\\\ContentCompSettings\", \"@id\": \"0x4255\", \"@type\": \"binary\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Settings that might be needed by the decompressor. For Header Stripping (`ContentCompAlgo`=3),\\nthe bytes that were removed from the beginning of each frame of the track.\" }, \"extension\": { \"@type\": \"stream copy\", \"@keep\": \"1\" } }, { \"@name\": \"ContentEncryption\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\\\\ContentEncoding\\\\ContentEncryption\", \"@id\": \"0x5035\", \"@type\": \"master\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Settings describing the encryption used.\\nThis element **MUST** be present if the value of `ContentEncodingType` is 1 (encryption) and **MUST** be ignored otherwise.\\nA `Matroska Player` **MAY** support encryption.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"ContentEncAlgo\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\\\\ContentEncoding\\\\ContentEncryption\\\\ContentEncAlgo\", \"@id\": \"0x47E1\", \"@type\": \"uinteger\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The encryption algorithm used.\" }, \"extension\": [{ \"@type\": \"enum source\", \"@registry\": \"Encryption Algorithm\", \"@policy\": \"First Come First Served\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }], \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"Not encrypted\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The data are not encrypted.\" } }, { \"@value\": \"1\", \"@label\": \"DES\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Data Encryption Standard (DES) [@?FIPS46-3].\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"This value **SHOULD** be avoided.\" }] }, { \"@value\": \"2\", \"@label\": \"3DES\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Triple Data Encryption Algorithm [@?SP800-67].\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"This value **SHOULD** be avoided.\" }] }, { \"@value\": \"3\", \"@label\": \"Twofish\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Twofish Encryption Algorithm [@?Twofish].\" } }, { \"@value\": \"4\", \"@label\": \"Blowfish\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Blowfish Encryption Algorithm [@?Blowfish].\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"This value **SHOULD** be avoided.\" }] }, { \"@value\": \"5\", \"@label\": \"AES\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Advanced Encryption Standard (AES) [@?FIPS197].\" } }] } }, { \"@name\": \"ContentEncKeyID\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\\\\ContentEncoding\\\\ContentEncryption\\\\ContentEncKeyID\", \"@id\": \"0x47E2\", \"@type\": \"binary\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"For public key algorithms, the ID of the public key that the data was encrypted with.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"ContentEncAESSettings\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\\\\ContentEncoding\\\\ContentEncryption\\\\ContentEncAESSettings\", \"@id\": \"0x47E7\", \"@type\": \"master\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Settings describing the encryption algorithm used.\" }, \"implementation_note\": { \"@note_attribute\": \"maxOccurs\", \"#text\": \"ContentEncAESSettings **MUST NOT** be set (maxOccurs=0) if ContentEncAlgo is not AES (5).\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"AESSettingsCipherMode\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\\\\ContentEncoding\\\\ContentEncryption\\\\ContentEncAESSettings\\\\AESSettingsCipherMode\", \"@id\": \"0x47E8\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@range\": \"not 0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The AES cipher mode used in the encryption.\" }, \"implementation_note\": { \"@note_attribute\": \"maxOccurs\", \"#text\": \"AESSettingsCipherMode **MUST NOT** be set (maxOccurs=0) if ContentEncAlgo is not AES (5).\" }, \"extension\": [{ \"@type\": \"enum source\", \"@registry\": \"AES Cipher Mode\", \"@policy\": \"First Come First Served\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }], \"restriction\": { \"enum\": [{ \"@value\": \"1\", \"@label\": \"AES-CTR\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Counter [@?SP800-38A]\" } }, { \"@value\": \"2\", \"@label\": \"AES-CBC\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Cipher Block Chaining [@?SP800-38A]\" } }] } }, { \"@name\": \"ContentSignature\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\\\\ContentEncoding\\\\ContentEncryption\\\\ContentSignature\", \"@id\": \"0x47E3\", \"@type\": \"binary\", \"@maxver\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A cryptographic signature of the contents.\" } }, { \"@name\": \"ContentSigKeyID\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\\\\ContentEncoding\\\\ContentEncryption\\\\ContentSigKeyID\", \"@id\": \"0x47E4\", \"@type\": \"binary\", \"@maxver\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"This is the ID of the private key that the data was signed with.\" } }, { \"@name\": \"ContentSigAlgo\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\\\\ContentEncoding\\\\ContentEncryption\\\\ContentSigAlgo\", \"@id\": \"0x47E5\", \"@type\": \"uinteger\", \"@maxver\": \"0\", \"@default\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The algorithm used for the signature.\" }, \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"Not signed\" }, { \"@value\": \"1\", \"@label\": \"RSA\" }] } }, { \"@name\": \"ContentSigHashAlgo\", \"@path\": \"\\\\Segment\\\\Tracks\\\\TrackEntry\\\\ContentEncodings\\\\ContentEncoding\\\\ContentEncryption\\\\ContentSigHashAlgo\", \"@id\": \"0x47E6\", \"@type\": \"uinteger\", \"@maxver\": \"0\", \"@default\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The hash algorithm used for the signature.\" }, \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"Not signed\" }, { \"@value\": \"1\", \"@label\": \"SHA1-160\" }, { \"@value\": \"2\", \"@label\": \"MD5\" }] } }, { \"@name\": \"Cues\", \"@path\": \"\\\\Segment\\\\Cues\", \"@id\": \"0x1C53BB6B\", \"@type\": \"master\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A `Top-Level Element` to speed seeking access. All entries are\\n local to the `Segment`.\" }, \"implementation_note\": { \"@note_attribute\": \"minOccurs\", \"#text\": \"This element **SHOULD** be set when the `Segment` is not transmitted as a live stream; see (#livestreaming).\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"CuePoint\", \"@path\": \"\\\\Segment\\\\Cues\\\\CuePoint\", \"@id\": \"0xBB\", \"@type\": \"master\", \"@minOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains all information relative to a seek point in the `Segment`.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"CueTime\", \"@path\": \"\\\\Segment\\\\Cues\\\\CuePoint\\\\CueTime\", \"@id\": \"0xB3\", \"@type\": \"uinteger\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Absolute timestamp of the seek point, expressed in Segment Ticks, which are based on `TimestampScale`; see (#timestamp-ticks).\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"CueTrackPositions\", \"@path\": \"\\\\Segment\\\\Cues\\\\CuePoint\\\\CueTrackPositions\", \"@id\": \"0xB7\", \"@type\": \"master\", \"@minOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains positions for different tracks corresponding to the timestamp.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"CueTrack\", \"@path\": \"\\\\Segment\\\\Cues\\\\CuePoint\\\\CueTrackPositions\\\\CueTrack\", \"@id\": \"0xF7\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The track for which a position is given.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"CueClusterPosition\", \"@path\": \"\\\\Segment\\\\Cues\\\\CuePoint\\\\CueTrackPositions\\\\CueClusterPosition\", \"@id\": \"0xF1\", \"@type\": \"uinteger\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `Segment Position` ((#segment-position)) of the `Cluster` containing the associated `Block`.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"CueRelativePosition\", \"@path\": \"\\\\Segment\\\\Cues\\\\CuePoint\\\\CueTrackPositions\\\\CueRelativePosition\", \"@id\": \"0xF0\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The relative position inside the `Cluster` of the referenced `SimpleBlock` or `BlockGroup`\\nwith 0 being the first possible position for an element inside that `Cluster`.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"CueDuration\", \"@path\": \"\\\\Segment\\\\Cues\\\\CuePoint\\\\CueTrackPositions\\\\CueDuration\", \"@id\": \"0xB2\", \"@type\": \"uinteger\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The duration of the block, expressed in Segment Ticks, which are based on `TimestampScale`; see (#timestamp-ticks).\\nIf missing, the track's `DefaultDuration` does not apply and no duration information is available in terms of the cues.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"CueBlockNumber\", \"@path\": \"\\\\Segment\\\\Cues\\\\CuePoint\\\\CueTrackPositions\\\\CueBlockNumber\", \"@id\": \"0x5378\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Number of the `Block` in the specified `Cluster`.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"CueCodecState\", \"@path\": \"\\\\Segment\\\\Cues\\\\CuePoint\\\\CueTrackPositions\\\\CueCodecState\", \"@id\": \"0xEA\", \"@type\": \"uinteger\", \"@minver\": \"2\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `Segment Position` ((#segment-position)) of the\\n Codec State corresponding to this `Cues` element. 0 means that the\\n data is taken from the initial `TrackEntry`.\" } }, { \"@name\": \"CueReference\", \"@path\": \"\\\\Segment\\\\Cues\\\\CuePoint\\\\CueTrackPositions\\\\CueReference\", \"@id\": \"0xDB\", \"@type\": \"master\", \"@minver\": \"2\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `Clusters` containing the referenced `Blocks`.\" } }, { \"@name\": \"CueRefTime\", \"@path\": \"\\\\Segment\\\\Cues\\\\CuePoint\\\\CueTrackPositions\\\\CueReference\\\\CueRefTime\", \"@id\": \"0x96\", \"@type\": \"uinteger\", \"@minver\": \"2\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Timestamp of the referenced `Block`, expressed in Segment Ticks which is based on `TimestampScale`; see (#timestamp-ticks).\" } }, { \"@name\": \"CueRefCluster\", \"@path\": \"\\\\Segment\\\\Cues\\\\CuePoint\\\\CueTrackPositions\\\\CueReference\\\\CueRefCluster\", \"@id\": \"0x97\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `Segment Position` of the `Cluster` containing the referenced `Block`.\" } }, { \"@name\": \"CueRefNumber\", \"@path\": \"\\\\Segment\\\\Cues\\\\CuePoint\\\\CueTrackPositions\\\\CueReference\\\\CueRefNumber\", \"@id\": \"0x535F\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@range\": \"not 0\", \"@default\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Number of the referenced `Block` of Track X in the specified `Cluster`.\" } }, { \"@name\": \"CueRefCodecState\", \"@path\": \"\\\\Segment\\\\Cues\\\\CuePoint\\\\CueTrackPositions\\\\CueReference\\\\CueRefCodecState\", \"@id\": \"0xEB\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@default\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `Segment Position` of the Codec State corresponding to this referenced element.\\n0 means that the data is taken from the initial `TrackEntry`.\" } }, { \"@name\": \"Attachments\", \"@path\": \"\\\\Segment\\\\Attachments\", \"@id\": \"0x1941A469\", \"@type\": \"master\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains attached files.\" } }, { \"@name\": \"AttachedFile\", \"@path\": \"\\\\Segment\\\\Attachments\\\\AttachedFile\", \"@id\": \"0x61A7\", \"@type\": \"master\", \"@minOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"An attached file.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"Attached\" } }, { \"@name\": \"FileDescription\", \"@path\": \"\\\\Segment\\\\Attachments\\\\AttachedFile\\\\FileDescription\", \"@id\": \"0x467E\", \"@type\": \"utf-8\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A human-friendly name for the attached file.\" } }, { \"@name\": \"FileName\", \"@path\": \"\\\\Segment\\\\Attachments\\\\AttachedFile\\\\FileName\", \"@id\": \"0x466E\", \"@type\": \"utf-8\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Filename of the attached file.\" } }, { \"@name\": \"FileMediaType\", \"@path\": \"\\\\Segment\\\\Attachments\\\\AttachedFile\\\\FileMediaType\", \"@id\": \"0x4660\", \"@type\": \"string\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Media type of the file following the format described in [@!RFC6838].\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"MimeType\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"FileData\", \"@path\": \"\\\\Segment\\\\Attachments\\\\AttachedFile\\\\FileData\", \"@id\": \"0x465C\", \"@type\": \"binary\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The data of the file.\" }, \"extension\": { \"@type\": \"stream copy\", \"@keep\": \"1\" } }, { \"@name\": \"FileUID\", \"@path\": \"\\\\Segment\\\\Attachments\\\\AttachedFile\\\\FileUID\", \"@id\": \"0x46AE\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"UID representing the file, as random as possible.\" }, \"extension\": { \"@type\": \"stream copy\", \"@keep\": \"1\" } }, { \"@name\": \"FileReferral\", \"@path\": \"\\\\Segment\\\\Attachments\\\\AttachedFile\\\\FileReferral\", \"@id\": \"0x4675\", \"@type\": \"binary\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A binary value that a track/codec can refer to when the attachment is needed.\" } }, { \"@name\": \"FileUsedStartTime\", \"@path\": \"\\\\Segment\\\\Attachments\\\\AttachedFile\\\\FileUsedStartTime\", \"@id\": \"0x4661\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The timestamp at which this optimized font attachment comes into context, expressed in Segment Ticks, which are based on\\n `TimestampScale`. See [@?DivXWorldFonts].\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"This element is reserved for future use and if written **MUST** be the segment start timestamp.\" }], \"extension\": { \"@type\": \"divx.com\", \"@divx\": \"1\" } }, { \"@name\": \"FileUsedEndTime\", \"@path\": \"\\\\Segment\\\\Attachments\\\\AttachedFile\\\\FileUsedEndTime\", \"@id\": \"0x4662\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The timestamp at which this optimized font attachment goes out of context, expressed in Segment Ticks, which are based on\\n `TimestampScale`. See [@?DivXWorldFonts].\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"This element is reserved for future use and if written **MUST** be the segment end timestamp.\" }], \"extension\": { \"@type\": \"divx.com\", \"@divx\": \"1\" } }, { \"@name\": \"Chapters\", \"@path\": \"\\\\Segment\\\\Chapters\", \"@id\": \"0x1043A770\", \"@type\": \"master\", \"@maxOccurs\": \"1\", \"@recurring\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A system to define basic menus and partition data.\\nFor more detailed information, see (#chapters).\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"EditionEntry\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\", \"@id\": \"0x45B9\", \"@type\": \"master\", \"@minOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains all information about a `Segment` edition.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"EditionUID\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\EditionUID\", \"@id\": \"0x45BC\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A UID that identifies the edition. It's useful for tagging an edition.\" }, \"extension\": { \"@type\": \"stream copy\", \"@keep\": \"1\" } }, { \"@name\": \"EditionFlagHidden\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\EditionFlagHidden\", \"@id\": \"0x45BD\", \"@type\": \"uinteger\", \"@range\": \"0-1\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Set to 1 if an edition is hidden. Hidden editions **SHOULD NOT** be available to the user interface\\n(but still be available to Control Tracks; see (#chapter-flags) on `Chapter` flags).\" }, \"extension\": { \"@type\": \"other document\", \"@spec\": \"control-track\" } }, { \"@name\": \"EditionFlagDefault\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\EditionFlagDefault\", \"@id\": \"0x45DB\", \"@type\": \"uinteger\", \"@range\": \"0-1\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Set to 1 if the edition **SHOULD** be used as the default one.\" } }, { \"@name\": \"EditionFlagOrdered\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\EditionFlagOrdered\", \"@id\": \"0x45DD\", \"@type\": \"uinteger\", \"@range\": \"0-1\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Set to 1 if the chapters can be defined multiple times and the order to play them is enforced; see (#editionflagordered).\" } }, { \"@name\": \"EditionDisplay\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\EditionDisplay\", \"@id\": \"0x4520\", \"@type\": \"master\", \"@minver\": \"5\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains a possible string to use for the edition display for the given languages.\" } }, { \"@name\": \"EditionString\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\EditionDisplay\\\\EditionString\", \"@id\": \"0x4521\", \"@type\": \"utf-8\", \"@minver\": \"5\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains the string to use as the edition name.\" } }, { \"@name\": \"EditionLanguageIETF\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\EditionDisplay\\\\EditionLanguageIETF\", \"@id\": \"0x45E4\", \"@type\": \"string\", \"@minver\": \"5\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"One language corresponding to the EditionString,\\nin the form defined in [@!RFC5646]; see (#language-codes) on language codes.\" } }, { \"@name\": \"ChapterAtom\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\", \"@id\": \"0xB6\", \"@type\": \"master\", \"@minOccurs\": \"1\", \"@recursive\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains the atom information to use as the chapter atom (applies to all tracks).\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"ChapterUID\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterUID\", \"@id\": \"0x73C4\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A UID that identifies the `Chapter`.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"stream copy\", \"@keep\": \"1\" }] }, { \"@name\": \"ChapterStringUID\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterStringUID\", \"@id\": \"0x5654\", \"@type\": \"utf-8\", \"@minver\": \"3\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A unique string ID that identifies the `Chapter`.\\nFor example, it is used as the storage for cue identifier values [@?WebVTT].\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"ChapterTimeStart\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterTimeStart\", \"@id\": \"0x91\", \"@type\": \"uinteger\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Timestamp of the start of `Chapter`, expressed in Matroska Ticks -- i.e., in nanoseconds; see (#timestamp-ticks).\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"ChapterTimeEnd\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterTimeEnd\", \"@id\": \"0x92\", \"@type\": \"uinteger\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Timestamp of the end of `Chapter` (timestamp excluded), expressed in Matroska Ticks -- i.e., in nanoseconds; see (#timestamp-ticks).\\nThe value **MUST** be greater than or equal to the `ChapterTimeStart` of the same `ChapterAtom`.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"With the `ChapterTimeEnd` timestamp value being excluded, it **MUST** take into account the duration of\\nthe last frame it includes, especially for the `ChapterAtom` using the last frames of the `Segment`.\" }], \"implementation_note\": { \"@note_attribute\": \"minOccurs\", \"#text\": \"ChapterTimeEnd **MUST** be set (minOccurs=1) if the `Edition` is an ordered edition; see (#editionflagordered). If it's a `Parent Chapter`, see (#nested-chapters).\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"ChapterFlagHidden\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterFlagHidden\", \"@id\": \"0x98\", \"@type\": \"uinteger\", \"@range\": \"0-1\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Set to 1 if a chapter is hidden.\\n Hidden chapters **SHOULD NOT** be available to the user interface\\n(but still be available to Control Tracks; see (#chapterflaghidden) on `Chapter` flags).\" } }, { \"@name\": \"ChapterFlagEnabled\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterFlagEnabled\", \"@id\": \"0x4598\", \"@type\": \"uinteger\", \"@range\": \"0-1\", \"@default\": \"1\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Set to 1 if the chapter is enabled. It can be enabled/disabled by a Control Track.\\nWhen disabled, the movie **SHOULD** skip all the content between the TimeStart and TimeEnd of this chapter; see (#chapter-flags) on `Chapter` flags.\" }, \"extension\": { \"@type\": \"other document\", \"@spec\": \"control-track\" } }, { \"@name\": \"ChapterSegmentUUID\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterSegmentUUID\", \"@id\": \"0x6E67\", \"@type\": \"binary\", \"@length\": \"16\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `SegmentUUID` of another `Segment` to play during this chapter.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"The value **MUST NOT** be the `SegmentUUID` value of the `Segment` it belongs to.\" }], \"implementation_note\": { \"@note_attribute\": \"minOccurs\", \"#text\": \"`ChapterSegmentUUID` **MUST** be set (minOccurs=1) if `ChapterSegmentEditionUID` is used; see (#medium-linking) on Medium-Linking `Segments`.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"ChapterSegmentUID\" } }, { \"@name\": \"ChapterSkipType\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterSkipType\", \"@id\": \"0x4588\", \"@type\": \"uinteger\", \"@minver\": \"5\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Indicates what type of content the `ChapterAtom` contains and might be skipped.\\n It can be used to automatically skip content based on the type.\\n If a `ChapterAtom` is inside a `ChapterAtom` that has a `ChapterSkipType` set, it\\n **MUST NOT** have a `ChapterSkipType` or have a `ChapterSkipType` with the same value as it's parent `ChapterAtom`.\\nIf the `ChapterAtom` doesn't contain a `ChapterTimeEnd`, the value of the `ChapterSkipType` is only valid until the next `ChapterAtom` with a `ChapterSkipType` value or the end of the file.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"0\" }, \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"No Skipping\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Content which should not be skipped.\" } }, { \"@value\": \"1\", \"@label\": \"Opening Credits\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Credits usually found at the beginning of the content.\" } }, { \"@value\": \"2\", \"@label\": \"End Credits\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Credits usually found at the end of the content.\" } }, { \"@value\": \"3\", \"@label\": \"Recap\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Recap of previous episodes of the content, usually found around the beginning.\" } }, { \"@value\": \"4\", \"@label\": \"Next Preview\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Preview of the next episode of the content, usually found around the end. It may contain spoilers the user wants to avoid.\" } }, { \"@value\": \"5\", \"@label\": \"Preview\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Preview of the current episode of the content, usually found around the beginning. It may contain spoilers the user want to avoid.\" } }, { \"@value\": \"6\", \"@label\": \"Advertisement\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Advertisement within the content.\" } }, { \"@value\": \"7\", \"@label\": \"Intermission\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A pause of content between main parts of the content.\" } }] } }, { \"@name\": \"ChapterSegmentEditionUID\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterSegmentEditionUID\", \"@id\": \"0x6EBC\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The `EditionUID` to play from the `Segment` linked in `ChapterSegmentUUID`.\\nIf `ChapterSegmentEditionUID` is undeclared, then no `Edition` of the `Linked Segment` is used; see (#medium-linking) on Medium-Linking `Segments`.\" } }, { \"@name\": \"ChapterPhysicalEquiv\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterPhysicalEquiv\", \"@id\": \"0x63C3\", \"@type\": \"uinteger\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Specifies the physical equivalent of this `ChapterAtom`, e.g., \\\"DVD\\\" (60) or \\\"SIDE\\\" (50);\\nsee (#physical-types) for a complete list of values.\" } }, { \"@name\": \"ChapterTrack\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterTrack\", \"@id\": \"0x8F\", \"@type\": \"master\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"List of tracks on which the chapter applies. If this element is not present, all tracks apply.\" }, \"extension\": { \"@type\": \"other document\", \"@spec\": \"control-track\" } }, { \"@name\": \"ChapterTrackUID\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterTrack\\\\ChapterTrackUID\", \"@id\": \"0x89\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@minOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"UID of the `Track` to apply this chapter to.\\nIn the absence of a control track, choosing this chapter will select the listed `Tracks` and deselect unlisted tracks.\\nAbsence of this element indicates that the `Chapter` **SHOULD** be applied to any currently used `Tracks`.\" }, \"extension\": [{ \"@type\": \"libmatroska\", \"@cppname\": \"ChapterTrackNumber\" }, { \"@type\": \"other document\", \"@spec\": \"control-track\" }] }, { \"@name\": \"ChapterDisplay\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterDisplay\", \"@id\": \"0x80\", \"@type\": \"master\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains all possible strings to use for the chapter display.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"ChapString\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterDisplay\\\\ChapString\", \"@id\": \"0x85\", \"@type\": \"utf-8\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains the string to use as the chapter atom.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"ChapterString\" }] }, { \"@name\": \"ChapLanguage\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterDisplay\\\\ChapLanguage\", \"@id\": \"0x437C\", \"@type\": \"string\", \"@default\": \"eng\", \"@minOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A language corresponding to the string,\\nin the Matroska languages form; see (#language-codes) on language codes.\\nThis element **MUST** be ignored if a `ChapLanguageBCP47` element is used within the same `ChapterDisplay` element.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"ChapterLanguage\" }] }, { \"@name\": \"ChapLanguageBCP47\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterDisplay\\\\ChapLanguageBCP47\", \"@id\": \"0x437D\", \"@type\": \"string\", \"@minver\": \"4\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A language corresponding to the `ChapString`,\\nin the form defined in [@!RFC5646]; see (#language-codes) on language codes.\\nIf a `ChapLanguageBCP47` element is used, then any `ChapLanguage` and `ChapCountry` elements used in the same `ChapterDisplay` **MUST** be ignored.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"ChapLanguageIETF\" } }, { \"@name\": \"ChapCountry\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapterDisplay\\\\ChapCountry\", \"@id\": \"0x437E\", \"@type\": \"string\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A country corresponding to the string,\\nin the Matroska countries form; see (#country-codes) on country codes.\\nThis element **MUST** be ignored if a `ChapLanguageBCP47` element is used within the same `ChapterDisplay` element.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"ChapterCountry\" }] }, { \"@name\": \"ChapProcess\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapProcess\", \"@id\": \"0x6944\", \"@type\": \"master\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains all the commands associated with the Atom.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"ChapterProcess\" } }, { \"@name\": \"ChapProcessCodecID\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapProcess\\\\ChapProcessCodecID\", \"@id\": \"0x6955\", \"@type\": \"uinteger\", \"@default\": \"0\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains the type of the codec used for processing.\" }, \"extension\": [{ \"@type\": \"enum source\", \"@registry\": \"Chapter Codec ID\", \"@policy\": \"Specification Required\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"ChapterProcessCodecID\" }], \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"Matroska Script\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Chapter commands using the Matroska Script codec.\" } }, { \"@value\": \"1\", \"@label\": \"DVD-menu\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Chapter commands using the DVD-like codec.\" } }] } }, { \"@name\": \"ChapProcessPrivate\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapProcess\\\\ChapProcessPrivate\", \"@id\": \"0x450D\", \"@type\": \"binary\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Optional data attached to the `ChapProcessCodecID` information.\\n For `ChapProcessCodecID` = 1, it is the \\\"DVD level\\\" equivalent; see (#menu-features) on DVD menus.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"ChapterProcessPrivate\" } }, { \"@name\": \"ChapProcessCommand\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapProcess\\\\ChapProcessCommand\", \"@id\": \"0x6911\", \"@type\": \"master\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains all the commands associated with the Atom.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"ChapterProcessCommand\" } }, { \"@name\": \"ChapProcessTime\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapProcess\\\\ChapProcessCommand\\\\ChapProcessTime\", \"@id\": \"0x6922\", \"@type\": \"uinteger\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Defines when the process command **SHOULD** be handled.\" }, \"restriction\": { \"enum\": [{ \"@value\": \"0\", \"@label\": \"during the whole chapter\" }, { \"@value\": \"1\", \"@label\": \"before starting playback\" }, { \"@value\": \"2\", \"@label\": \"after playback of the chapter\" }] }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"ChapterProcessTime\" } }, { \"@name\": \"ChapProcessData\", \"@path\": \"\\\\Segment\\\\Chapters\\\\EditionEntry\\\\+ChapterAtom\\\\ChapProcess\\\\ChapProcessCommand\\\\ChapProcessData\", \"@id\": \"0x6933\", \"@type\": \"binary\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains the command information.\\nThe data **SHOULD** be interpreted depending on the `ChapProcessCodecID` value. For `ChapProcessCodecID` = 1,\\nthe data correspond to the binary DVD cell pre/post commands; see (#menu-features) on DVD menus.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"ChapterProcessData\" } }, { \"@name\": \"Tags\", \"@path\": \"\\\\Segment\\\\Tags\", \"@id\": \"0x1254C367\", \"@type\": \"master\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Element containing metadata describing `Tracks`, `Editions`, `Chapters`, `Attachments`, or the `Segment` as a whole.\\nA list of valid tags can be found in [@?I-D.ietf-cellar-tags].\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"Tag\", \"@path\": \"\\\\Segment\\\\Tags\\\\Tag\", \"@id\": \"0x7373\", \"@type\": \"master\", \"@minOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A single metadata descriptor.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"Targets\", \"@path\": \"\\\\Segment\\\\Tags\\\\Tag\\\\Targets\", \"@id\": \"0x63C0\", \"@type\": \"master\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Specifies which other elements the metadata represented by the tag value applies to.\\nIf empty or omitted, then the tag value describes everything in the `Segment`.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"TagTargets\" }] }, { \"@name\": \"TargetTypeValue\", \"@path\": \"\\\\Segment\\\\Tags\\\\Tag\\\\Targets\\\\TargetTypeValue\", \"@id\": \"0x68CA\", \"@type\": \"uinteger\", \"@range\": \"not 0\", \"@default\": \"50\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A number to indicate the logical level of the target.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"The `TargetTypeValue` values are meant to be compared.\\n Higher values **MUST** correspond to a logical level that contains the lower logical level `TargetTypeValue` values.\" }], \"extension\": [{ \"@type\": \"enum source\", \"@registry\": \"Tags Target Type\", \"@policy\": \"Specification Required\" }, { \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"TagTargetTypeValue\" }], \"restriction\": { \"enum\": [{ \"@value\": \"10\", \"@label\": \"SHOT\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The lowest hierarchy found in music or movies.\" } }, { \"@value\": \"20\", \"@label\": \"SUBTRACK / MOVEMENT / SCENE\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Corresponds to parts of a track for audio, such as a movement or scene in a movie.\" } }, { \"@value\": \"30\", \"@label\": \"TRACK / SONG / CHAPTER\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The common parts of an album or movie.\" } }, { \"@value\": \"40\", \"@label\": \"PART / SESSION\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"When an album or episode has different logical parts.\" } }, { \"@value\": \"50\", \"@label\": \"ALBUM / OPERA / CONCERT / MOVIE / EPISODE\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The most common grouping level of music and video (e.g., an episode for TV series).\" } }, { \"@value\": \"60\", \"@label\": \"EDITION / ISSUE / VOLUME / OPUS / SEASON / SEQUEL\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A list of lower levels grouped together.\" } }, { \"@value\": \"70\", \"@label\": \"COLLECTION\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The highest hierarchical level that tags can describe.\" } }] } }, { \"@name\": \"TargetType\", \"@path\": \"\\\\Segment\\\\Tags\\\\Tag\\\\Targets\\\\TargetType\", \"@id\": \"0x63CA\", \"@type\": \"string\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"An informational string that can be used to display the logical level of the target, such as \\\"ALBUM\\\", \\\"TRACK\\\", \\\"MOVIE\\\", \\\"CHAPTER\\\", etc.\" }, \"restriction\": { \"enum\": [{ \"@value\": \"COLLECTION\", \"@label\": \"TargetTypeValue 70\" }, { \"@value\": \"EDITION\", \"@label\": \"TargetTypeValue 60\" }, { \"@value\": \"ISSUE\", \"@label\": \"TargetTypeValue 60\" }, { \"@value\": \"VOLUME\", \"@label\": \"TargetTypeValue 60\" }, { \"@value\": \"OPUS\", \"@label\": \"TargetTypeValue 60\" }, { \"@value\": \"SEASON\", \"@label\": \"TargetTypeValue 60\" }, { \"@value\": \"SEQUEL\", \"@label\": \"TargetTypeValue 60\" }, { \"@value\": \"ALBUM\", \"@label\": \"TargetTypeValue 50\" }, { \"@value\": \"OPERA\", \"@label\": \"TargetTypeValue 50\" }, { \"@value\": \"CONCERT\", \"@label\": \"TargetTypeValue 50\" }, { \"@value\": \"MOVIE\", \"@label\": \"TargetTypeValue 50\" }, { \"@value\": \"EPISODE\", \"@label\": \"TargetTypeValue 50\" }, { \"@value\": \"PART\", \"@label\": \"TargetTypeValue 40\" }, { \"@value\": \"SESSION\", \"@label\": \"TargetTypeValue 40\" }, { \"@value\": \"TRACK\", \"@label\": \"TargetTypeValue 30\" }, { \"@value\": \"SONG\", \"@label\": \"TargetTypeValue 30\" }, { \"@value\": \"CHAPTER\", \"@label\": \"TargetTypeValue 30\" }, { \"@value\": \"SUBTRACK\", \"@label\": \"TargetTypeValue 20\" }, { \"@value\": \"MOVEMENT\", \"@label\": \"TargetTypeValue 20\" }, { \"@value\": \"SCENE\", \"@label\": \"TargetTypeValue 20\" }, { \"@value\": \"SHOT\", \"@label\": \"TargetTypeValue 10\" }] }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"TagTargetType\" }] }, { \"@name\": \"TagTrackUID\", \"@path\": \"\\\\Segment\\\\Tags\\\\Tag\\\\Targets\\\\TagTrackUID\", \"@id\": \"0x63C5\", \"@type\": \"uinteger\", \"@default\": \"0\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A UID that identifies the `Track(s)` that the tags belong to.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"If the value is 0 at this level, the tags apply to all tracks in the `Segment`.\\nIf set to any other value, it **MUST** match the `TrackUID` value of a track found in this `Segment`.\" }], \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"TagEditionUID\", \"@path\": \"\\\\Segment\\\\Tags\\\\Tag\\\\Targets\\\\TagEditionUID\", \"@id\": \"0x63C9\", \"@type\": \"uinteger\", \"@default\": \"0\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A UID that identifies the `EditionEntry(s)` that the tags belong to.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"If the value is 0 at this level, the tags apply to all editions in the `Segment`.\\nIf set to any other value, it **MUST** match the `EditionUID` value of an edition found in this `Segment`.\" }] }, { \"@name\": \"TagChapterUID\", \"@path\": \"\\\\Segment\\\\Tags\\\\Tag\\\\Targets\\\\TagChapterUID\", \"@id\": \"0x63C4\", \"@type\": \"uinteger\", \"@default\": \"0\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A UID that identifies the `Chapter(s)` that the tags belong to.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"If the value is 0 at this level, the tags apply to all chapters in the `Segment`.\\nIf set to any other value, it **MUST** match the `ChapterUID` value of a chapter found in this `Segment`.\" }] }, { \"@name\": \"TagAttachmentUID\", \"@path\": \"\\\\Segment\\\\Tags\\\\Tag\\\\Targets\\\\TagAttachmentUID\", \"@id\": \"0x63C6\", \"@type\": \"uinteger\", \"@default\": \"0\", \"documentation\": [{ \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A UID that identifies the Attachment(s) that the tags belong to.\" }, { \"@lang\": \"en\", \"@purpose\": \"usage notes\", \"#text\": \"If the value is 0 at this level, the tags apply to all the attachments in\\n the `Segment`. If set to any other value, it **MUST** match\\n the `FileUID` value of an attachment found in this `Segment`.\" }] }, { \"@name\": \"SimpleTag\", \"@path\": \"\\\\Segment\\\\Tags\\\\Tag\\\\+SimpleTag\", \"@id\": \"0x67C8\", \"@type\": \"master\", \"@minOccurs\": \"1\", \"@recursive\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Contains general information about the target.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"TagSimple\" }] }, { \"@name\": \"TagName\", \"@path\": \"\\\\Segment\\\\Tags\\\\Tag\\\\+SimpleTag\\\\TagName\", \"@id\": \"0x45A3\", \"@type\": \"utf-8\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The name of the tag value that is going to be stored.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"TagLanguage\", \"@path\": \"\\\\Segment\\\\Tags\\\\Tag\\\\+SimpleTag\\\\TagLanguage\", \"@id\": \"0x447A\", \"@type\": \"string\", \"@default\": \"und\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"Specifies the language of the specified tag in the Matroska languages form; see (#language-codes) on language codes.\\nThis element **MUST** be ignored if the `TagLanguageBCP47` element is used within the same `SimpleTag` element.\" }, \"extension\": [{ \"@type\": \"webmproject.org\", \"@webm\": \"1\" }, { \"@type\": \"libmatroska\", \"@cppname\": \"TagLangue\" }] }, { \"@name\": \"TagLanguageBCP47\", \"@path\": \"\\\\Segment\\\\Tags\\\\Tag\\\\+SimpleTag\\\\TagLanguageBCP47\", \"@id\": \"0x447B\", \"@type\": \"string\", \"@minver\": \"4\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The language used in the `TagString`,\\nin the form defined in [@!RFC5646]; see (#language-codes) on language codes.\\nIf this element is used, then any `TagLanguage` elements used in the same `SimpleTag` **MUST** be ignored.\" }, \"extension\": { \"@type\": \"libmatroska\", \"@cppname\": \"TagLanguageIETF\" } }, { \"@name\": \"TagDefault\", \"@path\": \"\\\\Segment\\\\Tags\\\\Tag\\\\+SimpleTag\\\\TagDefault\", \"@id\": \"0x4484\", \"@type\": \"uinteger\", \"@range\": \"0-1\", \"@default\": \"1\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A boolean value to indicate if this is the default/original language to use for the given tag.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"TagDefaultBogus\", \"@path\": \"\\\\Segment\\\\Tags\\\\Tag\\\\+SimpleTag\\\\TagDefaultBogus\", \"@id\": \"0x44B4\", \"@type\": \"uinteger\", \"@minver\": \"0\", \"@maxver\": \"0\", \"@range\": \"0-1\", \"@default\": \"1\", \"@minOccurs\": \"1\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"A variant of the `TagDefault` element with a bogus element ID; see (#tagdefault-element).\" } }, { \"@name\": \"TagString\", \"@path\": \"\\\\Segment\\\\Tags\\\\Tag\\\\+SimpleTag\\\\TagString\", \"@id\": \"0x4487\", \"@type\": \"utf-8\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The tag value.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }, { \"@name\": \"TagBinary\", \"@path\": \"\\\\Segment\\\\Tags\\\\Tag\\\\+SimpleTag\\\\TagBinary\", \"@id\": \"0x4485\", \"@type\": \"binary\", \"@maxOccurs\": \"1\", \"documentation\": { \"@lang\": \"en\", \"@purpose\": \"definition\", \"#text\": \"The tag value if it is binary. Note that this cannot be used in the same `SimpleTag` as `TagString`.\" }, \"extension\": { \"@type\": \"webmproject.org\", \"@webm\": \"1\" } }] } };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Encoder = void 0;\nclass Encoder {\n    elements;\n    constructor(elements) {\n        this.elements = elements;\n    }\n    /**\n     * uintを表せる最小のbit数を返す\n     * @param uint\n     * @returns\n     */\n    getUintSize(uint) {\n        const nUint = BigInt(uint);\n        let length = 1;\n        while ((nUint >> BigInt(length)) !== 0n)\n            length++;\n        return length;\n    }\n    /**\n     * 整数をバッファに書き込む\n     * @param value\n     */\n    writeInt(type, value, byteLength) {\n        const isNegative = value < 0;\n        value = value < 0 ? -value : value;\n        if (byteLength == null) {\n            const bitLength = this.getUintSize(value);\n            byteLength = Math.ceil(bitLength / 8);\n            if (type == \"int\" && bitLength % 8 == 0) {\n                byteLength++;\n            }\n        }\n        value = BigInt(value);\n        const uint8Array = new Uint8Array(byteLength);\n        for (let i = 0; i < byteLength; i++) {\n            uint8Array[i] = Number((value >> (BigInt(byteLength - (i + 1))) * 8n) & 0xffn);\n        }\n        if (type == \"int\" && isNegative) {\n            uint8Array[0] |= 0x80;\n        }\n        return uint8Array.buffer;\n    }\n    /**\n     * 可変長整数をエンコードする\n     * @param start\n     * @returns\n     */\n    writeVint(value, withOctetLength = false) {\n        if (!withOctetLength) {\n            // TODO 元々の大きさを保持するパターンがあってもいい\n            const bitLength = this.getUintSize(value);\n            let octetLength = 0;\n            while (bitLength > octetLength * 8 - octetLength)\n                octetLength++;\n            value = BigInt(value);\n            const octetLengthBit = (0x80n << BigInt((octetLength - 1) * 8)) >> BigInt(octetLength - 1);\n            value |= octetLengthBit;\n        }\n        return this.writeInt(\"uint\", value);\n    }\n    /**\n     * バイナリデータにデコードする\n     * @returns\n     */\n    encode() {\n        const self = this;\n        let prev = -1;\n        return (function encode(elements = self.elements) {\n            const buffers = elements.map(e => {\n                const buffer = {};\n                // Element ID を書き込む\n                buffer.id = self.writeVint(e.id, true);\n                // データ部分\n                if (e.schema[\"@name\"] == \"SimpleBlock\") {\n                    const sb = e.data;\n                    prev = sb.Timestamp;\n                    const trackNumber = self.writeVint(sb.TrackNumber);\n                    const sbBuf = new Uint8Array(new ArrayBuffer(trackNumber.byteLength + 3 + sb.frameData.byteLength));\n                    let offset = 0;\n                    sbBuf.set(new Uint8Array(trackNumber), offset);\n                    offset += trackNumber.byteLength;\n                    sbBuf.set(new Uint8Array(self.writeInt(\"int\", sb.Timestamp, 2)), offset);\n                    offset += 2;\n                    let octet = (sb.KEY ? 1 : 0) << 7;\n                    octet |= sb.Rsvrd << 4;\n                    octet |= (sb.INV ? 1 : 0) << 3;\n                    octet |= sb.LACING << 1;\n                    octet |= sb.DIS ? 1 : 0;\n                    sbBuf.set(new Uint8Array([octet]), offset);\n                    offset++;\n                    sbBuf.set(new Uint8Array(sb.frameData), offset);\n                    buffer.data = sbBuf.buffer;\n                }\n                else {\n                    const typ = e.schema?.[\"@type\"];\n                    switch (typ) {\n                        case \"master\":\n                            buffer.data = encode(e.data);\n                            break;\n                        case \"integer\":\n                            buffer.data = self.writeInt(\"int\", e.data);\n                            break;\n                        case \"uinteger\":\n                            buffer.data = self.writeInt(\"uint\", e.data);\n                            break;\n                        case \"float\":\n                            const num = e.data;\n                            if (num != 0) {\n                                if (new Float32Array([num])[0] === num) {\n                                    const dataView = new DataView(new ArrayBuffer(4));\n                                    dataView.setFloat32(0, num, false);\n                                    buffer.data = dataView.buffer;\n                                }\n                                else {\n                                    const dataView = new DataView(new ArrayBuffer(8));\n                                    dataView.setFloat64(0, num, false);\n                                    buffer.data = dataView.buffer;\n                                }\n                            }\n                            break;\n                        case \"date\":\n                            let nanos = BigInt(new Date(2001, 0, 1).getTime()) * 1000n * 1000n;\n                            const nanoOffset = e.data[\"nanos\"] - nanos;\n                            if (nanoOffset != 0n) {\n                                buffer.data = BigInt64Array.of(nanoOffset).buffer;\n                            }\n                            break;\n                        default:\n                            switch (typ) {\n                                case \"string\": {\n                                    const str = e.data;\n                                    const uint8Array = new Uint8Array([...str].map(char => char.charCodeAt(0)));\n                                    buffer.data = uint8Array.buffer;\n                                    break;\n                                }\n                                case \"utf-8\": {\n                                    const str = e.data;\n                                    const encoder = new TextEncoder();\n                                    const uint8Array = encoder.encode(str);\n                                    buffer.data = uint8Array.buffer;\n                                    break;\n                                }\n                                default:\n                                    buffer.data = e.data;\n                                    break;\n                            }\n                            break;\n                    }\n                }\n                if (buffer.data == null) {\n                    buffer.data = new ArrayBuffer(0);\n                }\n                // Size（データ長）を書き込む\n                buffer.size = self.writeVint(e.schema[\"@unknownsizeallowed\"] != \"1\" ?\n                    buffer.data.byteLength : 0xffffffffffffffn);\n                return buffer;\n            });\n            const totalSize = buffers.reduce((p, c) => p + c.id.byteLength + c.size.byteLength + c.data.byteLength, 0);\n            const totalUint8Array = new Uint8Array(new ArrayBuffer(totalSize));\n            let offset = 0;\n            buffers.forEach(b => {\n                totalUint8Array.set(new Uint8Array(b.id), offset);\n                offset += b.id.byteLength;\n                totalUint8Array.set(new Uint8Array(b.size), offset);\n                offset += b.size.byteLength;\n                totalUint8Array.set(new Uint8Array(b.data), offset);\n                offset += b.data.byteLength;\n            });\n            return totalUint8Array.buffer;\n        })();\n    }\n}\nexports.Encoder = Encoder;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EbmlToJson = exports.LACING = void 0;\nconst Decoder_1 = require(\"./Decoder\");\nconst Encoder_1 = require(\"./Encoder\");\nconst EbmlSchemaJson_1 = require(\"./EbmlSchemaJson\");\nvar LACING;\n(function (LACING) {\n    LACING[LACING[\"No\"] = 0] = \"No\";\n    LACING[LACING[\"Xiph\"] = 1] = \"Xiph\";\n    LACING[LACING[\"EBML\"] = 3] = \"EBML\";\n    LACING[LACING[\"FixedSize\"] = 2] = \"FixedSize\";\n})(LACING || (exports.LACING = LACING = {}));\nfunction isPlainObject(obj) {\n    return obj !== null && typeof obj === \"object\" && obj.constructor === Object;\n}\nclass EbmlToJson {\n    elements;\n    tree;\n    notMathBuffer;\n    /**\n     * EBMLファイルを読み込み、プロパティに設定する\n     * @param buffer\n     */\n    constructor(buffer) {\n        this.elements = buffer ? new Decoder_1.Decoder(buffer).decode() : [];\n        const proxyToObject = new WeakMap();\n        const objectToProxy = new WeakMap();\n        function proxyFactry(targetObj, elements, elementName) {\n            if (targetObj == null || typeof (targetObj) != \"object\" || objectToProxy.has(targetObj))\n                return targetObj;\n            function getTargetElements(target, key) {\n                if (Array.isArray(target)) {\n                    const index = parseInt(key);\n                    return elements\n                        .filter(e => e.schema[\"@name\"] == elementName)\n                        .filter((_, i) => i == index);\n                }\n                else {\n                    return elements\n                        .filter(e => e.schema[\"@name\"] == key);\n                }\n            }\n            const proxy = new Proxy(targetObj, {\n                get(target, key) {\n                    if (key === \"toJSON\") {\n                        return () => {\n                            const replacer = (val) => {\n                                if (typeof (val.toJSON) == \"function\")\n                                    return val.toJSON();\n                                return val;\n                            };\n                            const proxy = objectToProxy.get(target);\n                            return Array.isArray(proxy) ?\n                                proxy.map(replacer) :\n                                Object.keys(proxy).reduce((p, c) => {\n                                    p[c] = replacer(proxy[c]);\n                                    return p;\n                                }, {});\n                        };\n                    }\n                    if (typeof (target[key]) == \"function\" || Array.isArray(target) && !/^[0-9]+$/.test(key)) {\n                        return target[key];\n                    }\n                    // アクセスしたキーに該当する要素を取得\n                    const targetElements = getTargetElements(target, key);\n                    // 要素に設定された値を取得\n                    const valueList = targetElements\n                        .map(e => Array.isArray(e.data) ?\n                        proxyFactry({}, e.data) :\n                        e.data);\n                    if (Array.isArray(target)) {\n                        // 配列の添字にアクセスしたら、その添字の要素を取得\n                        return valueList[0];\n                    }\n                    else {\n                        // ツリーのプロパティにアクセスしたら、対応する要素やその配列を返す\n                        const schema = EbmlSchemaJson_1.EbmlSchemaJson.EBMLSchema.element.filter(e => e[\"@name\"] == key)[0];\n                        if (valueList.length == 0)\n                            return undefined;\n                        else if (valueList.length == 1 && schema?.[\"@maxOccurs\"] == \"1\")\n                            return valueList[0];\n                        else\n                            return proxyFactry(valueList, elements, key);\n                    }\n                },\n                set(target, key, value) {\n                    if (Array.isArray(target) && !/^[0-9]+$/.test(key)) {\n                        return Reflect.set(target, key, value);\n                    }\n                    // アクセスしたキーに該当する要素を取得\n                    const targetElements = getTargetElements(target, key);\n                    // 配列化\n                    if (!Array.isArray(value)) {\n                        value = [value];\n                    }\n                    let i = 0;\n                    for (; i < value.length; i++) {\n                        const data = (function recursive(val) {\n                            if (isPlainObject(val)) {\n                                // オブジェクトを配列に変換\n                                return Object.keys(val).flatMap(k => {\n                                    const schema = EbmlSchemaJson_1.EbmlSchemaJson.EBMLSchema.element.filter(e => e[\"@name\"] == k)[0];\n                                    const vals = Array.isArray(val[k]) ? val[k] : [val[k]];\n                                    return vals.map(v => ({\n                                        id: schema ? BigInt(schema[\"@id\"]) : null,\n                                        pos: null,\n                                        size: null,\n                                        schema,\n                                        data: schema[\"@name\"] == \"SimpleBlock\" ? v : recursive(v) // SimpleBlockだけ例外\n                                    }));\n                                });\n                            }\n                            else {\n                                return val; // 配列の入れ子は構造上ありえない。そのまま返す\n                            }\n                        })(value[i]);\n                        if (i < targetElements.length) {\n                            // 既に存在する要素の値を更新\n                            targetElements[i].data = data;\n                        }\n                        else {\n                            // 新しい要素を追加\n                            const name = Array.isArray(target) ? elementName : key;\n                            const schema = EbmlSchemaJson_1.EbmlSchemaJson.EBMLSchema.element.filter(e => e[\"@name\"] == name)[0];\n                            elements.push({\n                                id: schema ? BigInt(schema[\"@id\"]) : null,\n                                pos: null,\n                                size: null,\n                                schema,\n                                data\n                            });\n                        }\n                    }\n                    // 余分な要素を削除\n                    targetElements.slice(i).forEach(v => {\n                        const i = elements.indexOf(v);\n                        elements.splice(i, 1);\n                    });\n                    return true;\n                },\n                ownKeys(target) {\n                    return Array.isArray(target) ?\n                        elements.filter(e => e.schema[\"@name\"] == elementName).map((_, i) => String(i)) :\n                        Array.from(new Set(elements.map(e => e.schema[\"@name\"])));\n                },\n                has(target, prop) {\n                    return this.ownKeys(target).includes(prop);\n                },\n                getOwnPropertyDescriptor(target, prop) {\n                    if (this.has(target, prop)) {\n                        return {\n                            enumerable: true,\n                            configurable: true\n                        };\n                    }\n                    return undefined;\n                },\n            });\n            proxyToObject.set(proxy, targetObj);\n            objectToProxy.set(targetObj, proxy);\n            return proxy;\n        }\n        this.tree = proxyFactry({}, this.elements);\n    }\n    /**\n     * データを結合して一つのEBMLにします\n     * @param ebmlToJson\n     */\n    append(ebmlToJson) {\n        for (const e of ebmlToJson.elements) {\n            const level = e.schema[\"@path\"].split(\"\\\\\").length - 1;\n            let parent = this.elements[this.elements.length - 1];\n            while (parent.schema[\"@path\"].split(\"\\\\\").length - 1 < level - 1) {\n                parent = parent.data[parent.data.length - 1];\n            }\n            parent.data.push(e);\n        }\n    }\n    /**\n     * EBMLをBlobにして返します。\n     * @param codecs\n     */\n    toBlob(codecs) {\n        const buf = this.toArrayBuffer();\n        return new Blob([buf], { type: `video/webm; codecs=\"${codecs}\"` });\n    }\n    /**\n     * EBMLをArrayBufferにして返します。\n     */\n    toArrayBuffer() {\n        const encoder = new Encoder_1.Encoder(this.elements);\n        return encoder.encode();\n    }\n    toJSON() {\n        return this.tree.toJSON();\n    }\n    static JSONReplacer(key, value) {\n        if (typeof (value) == \"bigint\")\n            return `Bigint ${value.toString()}n`;\n        if (value instanceof ArrayBuffer)\n            return `ArrayBuffer ${value.byteLength}bytes`;\n        return value;\n    }\n}\nexports.EbmlToJson = EbmlToJson;\n"],"names":[],"sourceRoot":""}